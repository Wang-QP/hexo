{"meta":{"title":"WQP","subtitle":null,"description":null,"author":"JasonWong","url":"https://wang-qp.github.io"},"pages":[{"title":"关于我","date":"2019-07-17T16:06:15.000Z","updated":"2020-06-04T00:57:09.312Z","comments":true,"path":"about/index.html","permalink":"https://wang-qp.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"test","slug":"test","date":"2020-06-04T01:42:38.000Z","updated":"2020-06-04T01:42:38.256Z","comments":true,"path":"2020/06/04/test/","link":"","permalink":"https://wang-qp.github.io/2020/06/04/test/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Centos7部署RocketMQ","slug":"rocketmq","date":"2020-06-03T07:00:20.000Z","updated":"2020-06-04T00:57:09.309Z","comments":true,"path":"2020/06/03/rocketmq/","link":"","permalink":"https://wang-qp.github.io/2020/06/03/rocketmq/","excerpt":"","text":"Centos7部署RocketMQ1. 环境准备系统环境：Centos7 x64 JDK：jdk-8u171-linux-x64 Maven：3.2.x以上的版本均可 2. 下载RocketMQ1wget https://mirrors.tuna.tsinghua.edu.cn/apache/rocketmq/4.7.0/rocketmq-all-4.7.0-source-release.zip 3. 解压1unzip -d /opt/myapp/ rocketmq-all-4.7.0-source-release.zip 4. 使用MAVEN进行打包 执行mvn打包会下好多的依赖包 ，时间较长 12345cd /opt/myapp/rocketmq-all-4.7.0/mvn -Prelease-all -DskipTests clean install -Ucd distribution/target/apache-rocketmq 5. 修改配置 一般到这里按照官方文档是可以启动的，但是最关键的一点，除了上面环境的要求外，还有个硬性要求，就是内存不能低于4G 12345678910111213141516cd binvim runserver.sh # 找到如下配置JAVA_OPT=\"$&#123;JAVA_OPT&#125; -server -Xms8g -Xmx8g -Xmn4g\"# 修改成你可以接受的范围JAVA_OPT=\"$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx521m -Xmn256m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m\"vim runbroker.sh# 找到如下配置JAVA_OPT=\"$&#123;JAVA_OPT&#125; -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m\"# 修改成你可以接受的范围JAVA_OPT=\"$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx512m -Xmn256m\" 6. 配置环境变量1234567vim /etc/profileexport ROCKETMQ_HOME=/opt/myapp/rocketmq/rocketmq-all-4.7.0-source-release/distribution/target/rocketmq-4.7.0/rocketmq-4.7.0export PATH=$&#123;ROCKETMQ_HOME&#125;/bin:$&#123;PATH&#125;# 使配置生效source /etc/profile 7. 启动Name Server123nohup sh mqnamesrv &amp;tail -f ~/logs/rocketmqlogs/namesrv.log 8. 启动Broker123nohup sh mqbroker -n localhost:9876 &amp;tail -f ~/logs/rocketmqlogs/broker.log 9. 执行测试添加环境变量： 1export NAMESRV_ADDR=localhost:9876 建议分别于不同两个窗口执行以下两个脚本 12# 生产者生产消息sh tools.sh org.apache.rocketmq.example.quickstart.Producer 12# 消费者消费消息sh tools.sh org.apache.rocketmq.example.quickstart.Consumer 10. 关闭服务12sh mqshutdown brokersh mqshutdown namesrv 11. 可视化服务配置11.1 下载123cd /opt/myjava/rocketmqgit clone https://github.com/apache/rocketmq-externals 11.2 修改配置文件12345678cd /opt/myjava/rocketmq/rocketmq-externals/rocketmq-console/src/main/resourcesvim application.properties# 修改如下配置server.port=8081 // 服务端口号rocketmq.config.namesrvAddr=127.0.0.1:9876 // 配置服务地址rocketmq.config.dataPath=/tmp/rocketmq-console/data // mq数据路径，可以自己修改 11.3 使用maven打包12cd /opt/myjava/rocketmq/rocketmq-externals/rocketmq-consolemvn clean package -Dmaven.test.skip=true 11.4 运行运行后访问对应的端口，如：http://192.168.159.100.8081 123cd /opt/myjava/rocketmq/rocketmq-externals/rocketmq-console/targetjava -jar rocketmq-console-ng-1.0.1.jar 指定端口运行和rocketmq地址运行 1java -jar rocketmq-console-ng-1.0.0.jar --server.port=8081 --rocketmq.config.namesrvAddr=127.0.0.1:9876 12. 自定义测试自动创建Topic 1nohup sh mqbroker -n localhost:9876 autoCreateTopicEnable=true &gt; ~/logs/rocketmqlogs/broker.log 2&gt;&amp;1 &amp; RocketMQ常用命令 1234567891011121314#查看所有消费组group:sh mqadmin consumerProgress -n 127.0.0.1:9876#查看所有topic:sh mqadmin topicList -n 127.0.0.1:9876#新增topic:sh mqadmin updateTopic -n localhost:9876 -b localhost:10911 -t mytopic#删除topicsh mqadmin deleteTopic –n 127.0.0.1:9876 –c DefaultCluster –t mytopic#查询集群消息sh mqadmin clusterList -n 127.0.0.1:9876 生产者: 12345678910111213141516171819202122232425import com.alibaba.rocketmq.client.producer.DefaultMQProducer;import com.alibaba.rocketmq.client.producer.SendResult;import com.alibaba.rocketmq.common.message.Message;public class ProducerTest &#123; public static void main(String[] args) throws Exception &#123; DefaultMQProducer producer = new DefaultMQProducer(\"producerGroup1\"); producer.setNamesrvAddr(\"192.168.159.100:9876\"); producer.setInstanceName(\"instance1\"); //为避免程序启动的时候报错，添加此代码，可以让rocketMq自动创建topickey producer.setCreateTopicKey(\"AUTO_CREATE_TOPIC_KEY\"); producer.start(); System.out.println(\"开始发送数据\"); try &#123; for (int i = 0; i &lt; 3; i++) &#123; Message msg = new Message(\"mytopic\", \"mytag\", (\"hello world \" + i).getBytes()); SendResult sendResult = producer.send(msg); System.out.println(\"发送成功 \" + new String(msg.getBody())); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; producer.shutdown(); &#125;&#125; 消费者: 123456789101112131415161718192021222324252627282930313233import com.alibaba.rocketmq.client.consumer.DefaultMQPushConsumer;import com.alibaba.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;import com.alibaba.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;import com.alibaba.rocketmq.client.consumer.listener.MessageListenerConcurrently;import com.alibaba.rocketmq.common.consumer.ConsumeFromWhere;import com.alibaba.rocketmq.common.message.Message;import com.alibaba.rocketmq.common.message.MessageExt;import java.util.List;public class ConsumerTest &#123; public static void main(String[] args) &#123; DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"producerGroup1\"); consumer.setNamesrvAddr(\"192.168.159.100:9876\"); System.out.println(\"开始接收数据\"); try &#123; // 设置topic和标签 consumer.subscribe(\"mytopic\", \"mytag\"); // 程序第一次启动从消息队列头取数据 consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); consumer.registerMessageListener(new MessageListenerConcurrently() &#123; public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext Context) &#123; Message msg = list.get(0); System.out.println(\"收到数据：\" + new String(msg.getBody())); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; &#125; &#125;); consumer.start(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"其他","slug":"其他","permalink":"https://wang-qp.github.io/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://wang-qp.github.io/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://wang-qp.github.io/categories/其他/"}]},{"title":"canal的使用","slug":"canal","date":"2020-06-02T04:04:32.000Z","updated":"2020-06-04T00:57:09.305Z","comments":true,"path":"2020/06/02/canal/","link":"","permalink":"https://wang-qp.github.io/2020/06/02/canal/","excerpt":"","text":"CentOS7安装Canal内容参考链接：https://blog.csdn.net/qrjqrjqrj/article/details/102979410 1 下载Canal( canal.deployer-1.1.4.tar.gz ) 2 解压到安装目录 1tar -zxvf canal.deployer-1.1.4.tar.gz -C /opt/myapp/canal 3 配置 3.1 mysql开启binlog 1vim /etc/my.cnf ** 在[mysqld]中添加下列语句 12345log-bin=mysql-binbinlog-format=ROWserver_id=1 ** 保存退出后重启mysql，执行systemctl restart mysql 123show variables like 'log_%';show variables like 'binlog_format'; 3.2 创建有slave权限的账号 1234--通过以下语句创建用户canal：create user canal@'%' identified by 'canal';--通过以下语句给用户授权：grant select, replication slave, replication client on *.* to canal@'%'; 3.3 修改Canal Server配置 1vim conf/example/instance.properties 123456canal.instance.mysql.slaveId=1234canal.instance.master.address=127.0.0.1:3306canal.instance.dbUsername=rootcanal.instance.dbPassword=123456 4 代码测试(mysql-&gt;redis) 4.1 pow.xml 1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;2.0.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.otter&lt;/groupId&gt; &lt;artifactId&gt;canal.client&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 4.2 CanalClient 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119import com.alibaba.fastjson.JSONObject;import com.alibaba.otter.canal.client.CanalConnector;import com.alibaba.otter.canal.client.CanalConnectors;import com.alibaba.otter.canal.protocol.CanalEntry.*;import com.alibaba.otter.canal.protocol.Message;import java.net.InetSocketAddress;import java.util.List;public class CanalClient &#123; public static void main(String args[]) &#123; CanalConnector connector = CanalConnectors.newSingleConnector(new InetSocketAddress(\"192.168.159.100\", 11111), \"example\", \"\", \"\"); int batchSize = 100; int emptyCount = 0; try &#123; connector.connect(); connector.subscribe(\".*\\\\..*\"); connector.rollback(); int i=0; while (true) &#123; // 获取指定数量的数据 Message message = connector.getWithoutAck(batchSize); long batchId = message.getId(); int size = message.getEntries().size();// System.out.println(\"batchId = \" + batchId);// System.out.println(\"size = \" + size); if (batchId == -1 || size == 0) &#123; emptyCount++;// System.out.println(\"empty count : \" + emptyCount); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; emptyCount = 0; printEntry(message.getEntries()); &#125; // 提交确认 connector.ack(batchId); // connector.rollback(batchId); // 处理失败, 回滚数据 &#125; &#125; finally &#123; connector.disconnect(); &#125; &#125; private static void printEntry(List&lt;Entry&gt; entrys) &#123; for (Entry entry : entrys) &#123; if (entry.getEntryType() == EntryType.TRANSACTIONBEGIN || entry.getEntryType() == EntryType.TRANSACTIONEND) &#123; continue; &#125; RowChange rowChage = null; try &#123; rowChage = RowChange.parseFrom(entry.getStoreValue()); &#125; catch (Exception e) &#123; throw new RuntimeException(\"ERROR ## parser of eromanga-event has an error , data:\" + entry.toString(), e); &#125; EventType eventType = rowChage.getEventType(); System.out.println(String.format(\"================&gt; binlog[%s:%s] , name[%s,%s] , eventType : %s\", entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(), entry.getHeader().getSchemaName(), entry.getHeader().getTableName(), eventType)); for (RowData rowData : rowChage.getRowDatasList()) &#123; if (eventType == EventType.DELETE) &#123; redisDelete(rowData.getBeforeColumnsList()); &#125; else if (eventType == EventType.INSERT) &#123; redisInsert(rowData.getAfterColumnsList()); &#125; else &#123; System.out.println(\"-------&gt; before\"); printColumn(rowData.getBeforeColumnsList()); System.out.println(\"-------&gt; after\"); printColumn(rowData.getAfterColumnsList()); redisUpdate(rowData.getAfterColumnsList()); &#125; &#125; &#125; &#125; private static void printColumn(List&lt;Column&gt; columns) &#123; for (Column column : columns) &#123; System.out.println(column.getName() + \" : \" + column.getValue() + \" update=\" + column.getUpdated()); &#125; &#125; private static void redisInsert(List&lt;Column&gt; columns) &#123; JSONObject json = new JSONObject(); for (Column column : columns) &#123; json.put(column.getName(), column.getValue()); &#125; if (columns.size() &gt; 0) &#123; RedisUtil.stringSet(\"user:\" + columns.get(0).getValue(), json.toJSONString()); &#125; &#125; private static void redisUpdate(List&lt;Column&gt; columns) &#123; JSONObject json = new JSONObject(); for (Column column : columns) &#123; json.put(column.getName(), column.getValue()); &#125; if (columns.size() &gt; 0) &#123; RedisUtil.stringSet(\"user:\" + columns.get(0).getValue(), json.toJSONString()); &#125; &#125; private static void redisDelete(List&lt;Column&gt; columns) &#123; JSONObject json = new JSONObject(); for (Column column : columns) &#123; json.put(column.getName(), column.getValue()); &#125; if (columns.size() &gt; 0) &#123; RedisUtil.delKey(\"user:\" + columns.get(0).getValue()); &#125; &#125;&#125; 3RedisUtil 1234567891011121314151617181920212223242526272829303132333435import redis.clients.jedis.Jedis;public class RedisUtil &#123; private static Jedis jedis = null; public static synchronized Jedis getJedis() &#123; if (jedis == null) &#123; jedis = new Jedis(\"127.0.0.1\", 6379);// jedis.auth(\"password\"); &#125; return jedis; &#125; public static boolean existKey(String key) &#123; return getJedis().exists(key); &#125; public static void delKey(String key) &#123; getJedis().del(key); &#125; public static String stringGet(String key) &#123; return getJedis().get(key); &#125; public static String stringSet(String key, String value) &#123; return getJedis().set(key, value); &#125; public static void hashSet(String key, String field, String value) &#123; getJedis().hset(key, field, value); &#125;&#125;","categories":[{"name":"其他","slug":"其他","permalink":"https://wang-qp.github.io/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://wang-qp.github.io/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://wang-qp.github.io/categories/其他/"}]},{"title":"CentOS防火墙设置","slug":"centos防火墙","date":"2020-06-02T04:00:32.000Z","updated":"2020-06-04T00:57:09.305Z","comments":true,"path":"2020/06/02/centos防火墙/","link":"","permalink":"https://wang-qp.github.io/2020/06/02/centos防火墙/","excerpt":"","text":"CentOS 6、CentOS7 防火墙端口设置CentOS 6.51.开放指定端口/sbin/iptables -I INPUT -p tcp –dport 端口号 -j ACCEPT //写入修改/etc/init.d/iptables save //保存修改service iptables restart //重启防火墙，修改生效2.关闭指定端口/sbin/iptables -I INPUT -p tcp –dport 端口号 -j DROP //写入修改/etc/init.d/iptables save //保存修改service iptables restart //重启防火墙，修改生效3.查看端口状态/etc/init.d/iptables status CentOS 71.防火墙操作启动： systemctl start firewalld查看状态： systemctl status firewalld停止： systemctl disable firewalld禁用： systemctl stop firewalld2.开放指定端口firewall-cmd –zone=public –add-port=80/tcp –permanent //开放端口firewall-cmd –reload //重新载入，使其生效3.关闭指定端口firewall-cmd –zone=public –remove-port=80/tcp –permanent //关闭端口firewall-cmd –reload //重新载入，使其生效4.查看端口状态firewall-cmd –zone=public –query-port=80/tcp //查看端口状态","categories":[{"name":"其他","slug":"其他","permalink":"https://wang-qp.github.io/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://wang-qp.github.io/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://wang-qp.github.io/categories/其他/"}]},{"title":"SpringCloud_高可用的分布式配置中心","slug":"SpringCloud-高可用的分布式配置中心","date":"2019-10-11T12:14:10.000Z","updated":"2020-06-04T00:57:09.299Z","comments":true,"path":"2019/10/11/SpringCloud-高可用的分布式配置中心/","link":"","permalink":"https://wang-qp.github.io/2019/10/11/SpringCloud-高可用的分布式配置中心/","excerpt":"","text":"高可用的分布式配置中心 配置中心如何从远程git读取配置文件，当服务实例很多时，都从配置中心读取文件，这时可以考虑将配置中心做成一个微服务，将其集群化，从而达到高可用 准备工作 使用上一篇文章的工程，创建一个eureka-server工程，用作服务注册中心。 在其pom.xml文件引入Eureka的起步依赖spring-cloud-starter-eureka-server 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 在配置文件application.yml上，指定服务端口为8889，加上作为服务注册中心的基本配置 1234567891011server: port: 8889eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 入口类： 12345678@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 改造config-server pom.xml文件加上EurekaClient的起步依赖spring-cloud-starter-eureka 12345678910111213141516171819202122&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-netflix-eureka-server&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置文件application.properties，指定服务注册地址为http://localhost:8889/eureka/ 123456789spring.application.name=config-serverserver.port=8888spring.cloud.config.server.git.uri=https://github.com/forezp/SpringcloudConfig/spring.cloud.config.server.git.searchPaths=respospring.cloud.config.label=masterspring.cloud.config.server.git.username= your usernamespring.cloud.config.server.git.password= your passwordeureka.client.serviceUrl.defaultZone=http://localhost:8889/eureka/ 入口类 12345678910@SpringBootApplication@EnableConfigServer@EnableEurekaClientpublic class ConfigServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigServiceApplication.class, args); &#125;&#125; 改造config-client 将其注册微到服务注册中心，作为Eureka客户端，需要pom文件加上起步依赖spring-cloud-starter-eureka 1234567891011121314151617181920212223242526272829&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-netflix-eureka-server&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置文件bootstrap.properties，注意是bootstrap。加上服务注册地址为http://localhost:8889/eureka/ 123456789spring.application.name=config-clientspring.cloud.config.label=masterspring.cloud.config.profile=dev#spring.cloud.config.uri= http://localhost:8888/eureka.client.serviceUrl.defaultZone=http://localhost:8889/eureka/spring.cloud.config.discovery.enabled=truespring.cloud.config.discovery.serviceId=config-serverserver.port=8881 spring.cloud.config.discovery.enabled 是从配置中心读取文件。 spring.cloud.config.discovery.serviceId 配置中心的servieId，即服务名。 在读取配置文件不再写ip地址，而是服务名，这时如果配置服务部署多份，通过负载均衡，从而高可用。 依次启动eureka-servr,config-server,config-client 访问网址：http://localhost:8889/ 访问http://localhost:8881/hi，浏览器显示： foo version 3","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"SpringCloud_config","slug":"SpringCloud-config","date":"2019-10-11T12:13:03.000Z","updated":"2020-06-04T00:57:09.298Z","comments":true,"path":"2019/10/11/SpringCloud-config/","link":"","permalink":"https://wang-qp.github.io/2019/10/11/SpringCloud-config/","excerpt":"","text":"config简介 在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。 构建Config Server 创建一个spring-boot项目，取名为config-server 引入依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 在程序的入口Application类加上@EnableConfigServer注解开启配置服务器的功能 12345678@SpringBootApplication@EnableConfigServerpublic class ConfigServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigServerApplication.class, args); &#125;&#125; 需要在程序的配置文件application.properties文件配置以下 123456789spring.application.name=config-serverserver.port=8888spring.cloud.config.server.git.uri=https://github.com/forezp/SpringcloudConfig/spring.cloud.config.server.git.searchPaths=respospring.cloud.config.label=masterspring.cloud.config.server.git.username=your usernamespring.cloud.config.server.git.password=your password spring.cloud.config.server.git.uri：配置git仓库地址 spring.cloud.config.server.git.searchPaths：配置仓库路径 spring.cloud.config.label：配置仓库的分支 spring.cloud.config.server.git.username：访问git仓库的用户名 spring.cloud.config.server.git.password：访问git仓库的用户密码 如果Git仓库为公开仓库，可以不填写用户名和密码，如果是私有仓库需要填写 启动程序：访问http://localhost:8888/foo/dev http请求地址和资源文件映射如下: /{application}/{profile}[/{label}] /{application}-{profile}.yml /{label}/{application}-{profile}.yml /{application}-{profile}.properties /{label}/{application}-{profile}.properties 构建一个config client 重新创建一个springboot项目，取名为config-client 引入依赖123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 配置文件12345spring.application.name=config-clientspring.cloud.config.label=masterspring.cloud.config.profile=devspring.cloud.config.uri= http://localhost:8888/server.port=8881 spring.cloud.config.label 指明远程仓库的分支 spring.cloud.config.profile dev开发环境配置文件 test测试环境 pro正式环境 spring.cloud.config.uri= http://localhost:8888/ 指明配置服务中心的网址。 入口类 程序的入口类，写一个API接口“／hi”，返回从配置中心读取的foo变量的值 123456789101112131415@SpringBootApplication@RestControllerpublic class ConfigClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigClientApplication.class, args); &#125; @Value(\"$&#123;foo&#125;\") String foo; @RequestMapping(value = \"/hi\") public String hi()&#123; return foo; &#125;&#125; 打开网址访问：http://localhost:8881/hi，网页显示： foo version 3 这就说明，config-client从config-server获取了foo的属性，而config-server是从git仓库读取的","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"SpringCloud_zuul","slug":"SpringCloud-zuul","date":"2019-10-11T12:12:09.000Z","updated":"2020-06-04T00:57:09.299Z","comments":true,"path":"2019/10/11/SpringCloud-zuul/","link":"","permalink":"https://wang-qp.github.io/2019/10/11/SpringCloud-zuul/","excerpt":"","text":"Zuul简介 Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。 zuul有以下功能： Authentication Insights Stress Testing Canary Testing Dynamic Routing Service Migration Load Shedding Security Static Response handling Active/Active traffic management 准备工作 在原有的工程上，创建一个新的工程。 创建service-zuul工程 引入依赖 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 在其入口applicaton类加上注解@EnableZuulProxy，开启zuul的功能 12345678@EnableZuulProxy@EnableEurekaClient@SpringBootApplicationpublic class ServiceZuulApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceZuulApplication.class, args); &#125;&#125; 加上配置文件application.yml加上以下的配置代码 1234567891011121314151617eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/server: port: 8769spring: application: name: service-zuulzuul: routes: api-a: path: /api-a/** serviceId: service-ribbon api-b: path: /api-b/** serviceId: service-feign 首先指定服务注册中心的地址为http://localhost:8761/eureka/，服务的端口为8769，服务名为service-zuul；以/api-a/ 开头的请求都转发给service-ribbon服务；以/api-b/开头的请求都转发给service-feign服务； 依次运行这五个工程;打开浏览器访问：http://localhost:8769/api-a/hi?name=wang ;浏览器显示： hi wang,i am from port:8762 打开浏览器访问：http://localhost:8769/api-b/hi?name=wang ;浏览器显示： hi wang,i am from port:8762 这说明zuul起到了路由的作用 服务过滤 zuul不仅只是路由，并且还能过滤，做一些安全验证。继续改造工程: 123456789101112131415161718192021222324252627282930313233343536373839@Componentpublic class MyFilter extends ZuulFilter&#123; private static Logger log = LoggerFactory.getLogger(MyFilter.class); @Override public String filterType() &#123; return \"pre\"; &#125; @Override public int filterOrder() &#123; return 0; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() &#123; RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); log.info(String.format(\"%s &gt;&gt;&gt; %s\", request.getMethod(), request.getRequestURL().toString())); Object accessToken = request.getParameter(\"token\"); if(accessToken == null) &#123; log.warn(\"token is empty\"); ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); try &#123; ctx.getResponse().getWriter().write(\"token is empty\"); &#125;catch (Exception e)&#123;&#125; return null; &#125; log.info(\"ok\"); return null; &#125;&#125; filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下： pre：路由之前 routing：路由之时 post： 路由之后 error：发送错误调用 filterOrder：过滤的顺序 shouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。 run：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。 1234这时访问：http://localhost:8769/api-a/hi?name=wang ；网页显示： token is empty访问 http://localhost:8769/api-a/hi?name=wang&amp;token=22 ； 网页显示： hi wang,i am from port:8762","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"SpringCloud_hystrix","slug":"SpringCloud-hystrix","date":"2019-10-11T12:09:48.000Z","updated":"2020-06-04T00:57:09.298Z","comments":true,"path":"2019/10/11/SpringCloud-hystrix/","link":"","permalink":"https://wang-qp.github.io/2019/10/11/SpringCloud-hystrix/","excerpt":"","text":"hystrixribbon中使用断路器概述 在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。 为了解决这个问题，业界提出了断路器模型。 准备工作 启动eureka-server 工程；启动service-hi工程，它的端口为8762。 在ribbon使用断路器 改造serice-ribbon 工程的代码，首先在pox.xml文件中加入spring-cloud-starter-hystrix的起步依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 在程序的启动类ServiceRibbonApplication 加@EnableHystrix注解开启Hystrix 12345678910111213141516@SpringBootApplication@EnableDiscoveryClient@EnableHystrixpublic class ServiceRibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceRibbonApplication.class, args); &#125; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 改造HelloService类，在hiService方法上加上@HystrixCommand注解。该注解对该方法创建了熔断器的功能，并指定了fallbackMethod熔断方法，熔断方法直接返回了一个字符串 123456789101112131415@Servicepublic class HelloService &#123; @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = \"hiError\") public String hiService(String name) &#123; return restTemplate.getForObject(\"http://SERVICE-HI/hi?name=\"+name,String.class); &#125; public String hiError(String name) &#123; return \"hi,\"+name+\",sorry,error!\"; &#125;&#125; 启动：service-ribbon 工程，当我们访问http://localhost:8764/hi?name=wang,浏览器显示： hi wang,i am from port:8762 此时关闭 service-hi 工程，当我们再访问http://localhost:8764/hi?name=wang，浏览器会显示： hi ,wang,orry,error! Feign中使用断路器 Feign是自带断路器的，在D版本的Spring Cloud中，它没有默认打开。需要在配置文件中配置打开它 1feign.hystrix.enabled=true 基于service-feign工程进行改造，只需要在FeignClient的SchedualServiceHi接口的注解中加上fallback的指定类 12345@FeignClient(value = \"service-hi\",fallback = SchedualServiceHiHystric.class)public interface SchedualServiceHi &#123; @RequestMapping(value = \"/hi\",method = RequestMethod.GET) String sayHiFromClientOne(@RequestParam(value = \"name\") String name);&#125; SchedualServiceHiHystric需要实现SchedualServiceHi 接口，并注入到Ioc容器中 1234567@Componentpublic class SchedualServiceHiHystric implements SchedualServiceHi &#123; @Override public String sayHiFromClientOne(String name) &#123; return \"sorry \"+name; &#125;&#125; 运行效果同上 Hystrix Dashboard (断路器：Hystrix 仪表盘) 基于service-ribbon 改造，Feign的改造和这一样。 首选在pom.xml引入spring-cloud-starter-hystrix-dashboard的起步依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt; 在主程序启动类中加入@EnableHystrixDashboard注解，开启hystrixDashboard 1234567891011121314151617@SpringBootApplication@EnableDiscoveryClient@EnableHystrix@EnableHystrixDashboardpublic class ServiceRibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceRibbonApplication.class, args); &#125; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 打开浏览器：访问http://localhost:8764/hystrix 点击monitor stream，进入下一个界面，访问：http://localhost:8764/hi?name=forezp 此时会出现监控界面","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"SpringCloud_feign","slug":"SpringCloud-feign","date":"2019-10-11T12:07:23.000Z","updated":"2020-06-04T00:57:09.298Z","comments":true,"path":"2019/10/11/SpringCloud-feign/","link":"","permalink":"https://wang-qp.github.io/2019/10/11/SpringCloud-feign/","excerpt":"","text":"Feign简介 Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。 简而言之： Feign 采用的是基于接口的注解 Feign 整合了ribbon 准备工作 新建一个spring-boot工程，取名为serice-feign，在它的pom文件引入Feign的起步依赖spring-cloud-starter-feign、Eureka的起步依赖spring-cloud-starter-eureka、Web的起步依赖spring-boot-starter-web 创建项目 引入依赖 12345678910111213141516171819202122&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 在工程的配置文件application.yml文件，指定程序名为service-feign，端口号为8765，服务注册地址为http://localhost:8761/eureka/ 123456789eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/server: port: 8765spring: application: name: service-feign 在程序的启动类ServiceFeignApplication ，加上@EnableFeignClients注解开启Feign的功能 123456789@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class ServiceFeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceFeignApplication.class, args); &#125;&#125; 定义一个feign接口，通过@ FeignClient（“服务名”），来指定调用哪个服务。比如在代码中调用了service-hi服务的“/hi”接口 12345@FeignClient(value = \"service-hi\")public interface SchedualServiceHi &#123; @RequestMapping(value = \"/hi\",method = RequestMethod.GET) String sayHiFromClientOne(@RequestParam(value = \"name\") String name);&#125; 在Web层的controller层，对外暴露一个”/hi”的API接口，通过上面定义的Feign客户端SchedualServiceHi 来消费服务 12345678910@RestControllerpublic class HiController &#123; @Autowired SchedualServiceHi schedualServiceHi; @RequestMapping(value = \"/hi\",method = RequestMethod.GET) public String sayHi(@RequestParam String name)&#123; return schedualServiceHi.sayHiFromClientOne(name); &#125;&#125; 在浏览器上多次访问http://localhost:8765/hi?name=wang，浏览器交替显示： hi wang,i am from port:8762 hi wang,i am from port:8763","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"SpringCloud_ribbon","slug":"SpringCloud_ribbon","date":"2019-10-11T12:04:34.000Z","updated":"2020-06-04T00:57:09.299Z","comments":true,"path":"2019/10/11/SpringCloud_ribbon/","link":"","permalink":"https://wang-qp.github.io/2019/10/11/SpringCloud_ribbon/","excerpt":"","text":"ribbon用途 在微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于http restful的。Spring cloud有两种服务调用方式，一种是ribbon+restTemplate，另一种是feign。 简介 ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。Feign默认集成了ribbon。 ribbon 已经默认实现了这些配置bean： IClientConfig ribbonClientConfig: DefaultClientConfigImpl IRule ribbonRule: ZoneAvoidanceRule IPing ribbonPing: NoOpPing ServerList ribbonServerList: ConfigurationBasedServerList ServerListFilter ribbonServerListFilter: ZonePreferenceServerListFilter ILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer 准备工作 基于上一篇文章的工程，启动eureka-server 工程；启动service-hi工程，它的端口为8762；将service-hi的配置文件的端口改为8763,并启动，这时：service-hi在eureka-server注册了2个实例，这就相当于一个小的集群。 建一个服务消费者 引入依赖 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 配置 123456789eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/server: port: 8764spring: application: name: service-ribbon 在工程的启动类中,通过@EnableDiscoveryClient向服务中心注册； 向程序的ioc注入一个bean: restTemplate; 通过@LoadBalanced注解表明这个restRemplate开启负载均衡的功能。 123456789101112131415@SpringBootApplication@EnableDiscoveryClientpublic class ServiceRibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceRibbonApplication.class, args); &#125; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 写一个测试类HelloService，通过之前注入ioc容器的restTemplate来消费service-hi服务的“/hi”接口，在这里我们直接用的程序名替代了具体的url地址，在ribbon中它会根据服务名来选择具体的服务实例，根据服务实例在请求的时候会用具体的url替换掉服务名，代码如下： 1234567891011@Servicepublic class HelloService &#123; @Autowired RestTemplate restTemplate; public String hiService(String name) &#123; return restTemplate.getForObject(\"http://SERVICE-HI/hi?name=\"+name,String.class); &#125;&#125; 写一个controller，在controller中用调用HelloService 的方法，代码如下： 12345678910@RestControllerpublic class HelloControler &#123; @Autowired HelloService helloService; @RequestMapping(value = \"/hi\") public String hi(@RequestParam String name)&#123; return helloService.hiService(name); &#125;&#125; 在浏览器上多次访问http://localhost:8764/hi?name=wang，浏览器交替显示： hi wang,i am from port:8762 hi wang,i am from port:8763","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"SpringCloud入门1：创建工程","slug":"SpringCloud入门1：创建工程","date":"2019-10-11T00:37:02.000Z","updated":"2020-06-04T00:57:09.300Z","comments":true,"path":"2019/10/11/SpringCloud入门1：创建工程/","link":"","permalink":"https://wang-qp.github.io/2019/10/11/SpringCloud入门1：创建工程/","excerpt":"","text":"SpringCloud入门SpringCloud简介 spring cloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。它运行环境简单，可以在开发人员的电脑上跑。 spring cloud是基于springboot的。项目创建 右键工程-&gt;创建model-&gt; 选择spring initialir 下一步-&gt;选择cloud discovery-&gt;eureka server EurekaServer 只需要一个注解@EnableEurekaServer 1234567@EnableEurekaServer@SpringBootApplicationpublic class EurekaserverApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaserverApplication.class, args); &#125;&#125; eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下erureka server也是一个eureka client ,必须要指定一个 server appication.yml 1234567891011server: port: 8761eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ EurekaClient 注解@EnableEurekaClient 表明自己是一个eurekaclient 123456789101112131415@SpringBootApplication@EnableEurekaClient@RestControllerpublic class ServiceHiApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceHiApplication.class, args); &#125; @Value(\"$&#123;server.port&#125;\") String port; @RequestMapping(\"/hi\") public String home(@RequestParam String name) &#123; return \"hi \"+name+\",i am from port:\" +port; &#125;&#125; application.yml 123456789eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/server: port: 8762spring: application: name: service-hi","categories":[],"tags":[],"keywords":[]},{"title":"SpringBoot入门6：整合redis","slug":"SpringBoot入门6：整合redis","date":"2019-10-10T06:30:38.000Z","updated":"2020-06-04T00:57:09.297Z","comments":true,"path":"2019/10/10/SpringBoot入门6：整合redis/","link":"","permalink":"https://wang-qp.github.io/2019/10/10/SpringBoot入门6：整合redis/","excerpt":"","text":"SpringBoot整合redis引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 配置数据源1234567891011spring: redis: host: localhost port: 6379 database: 1 timeout: 5000 pool: max-active: 8 max-wait: -1 max-idle: 500 min-idle: 0 Dao层12345678910111213141516@Repositorypublic class RedisDao &#123; @Autowired private StringRedisTemplate template; public void setKey(String key,String value)&#123; ValueOperations&lt;String, String&gt; ops = template.opsForValue(); ops.set(key,value,1, TimeUnit.MINUTES);//1分钟过期 &#125; public String getValue(String key)&#123; ValueOperations&lt;String, String&gt; ops = this.template.opsForValue(); return ops.get(key); &#125;&#125; 单元测试12345678910111213141516171819@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringbootRedisApplicationTests &#123; public static Logger logger= LoggerFactory.getLogger(SpringbootRedisApplicationTests.class); @Test public void contextLoads() &#123; &#125; @Autowired RedisDao redisDao; @Test public void testRedis()&#123; redisDao.setKey(\"name\",\"wang\"); redisDao.setKey(\"age\",\"18\"); logger.info(redisDao.getValue(\"name\")); logger.info(redisDao.getValue(\"age\")); &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"SpringBoot入门5：整合mybatis","slug":"SpringBoot入门5：整合mybatis","date":"2019-10-10T06:15:24.000Z","updated":"2020-06-04T00:57:09.297Z","comments":true,"path":"2019/10/10/SpringBoot入门5：整合mybatis/","link":"","permalink":"https://wang-qp.github.io/2019/10/10/SpringBoot入门5：整合mybatis/","excerpt":"","text":"SpringBoot整合mybatis引入依赖12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.29&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 配置数据源使用注解123456spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC username: root password: root 使用xml123456spring.datasource.url=jdbc:mysql://localhost:3306/testspring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc.Drivermybatis.mapper-locations=classpath*:mybatis/*Mapper.xmlmybatis.type-aliases-package=com.forezp.entity Dao层使用注解1234567891011121314151617@Mapperpublic interface AccountDao &#123; @Insert(\"insert into account(name,money) value(#&#123;name&#125;,#&#123;money&#125;)\") public int add(@Param(\"name\") String name, @Param(\"money\") double money); @Update(\"update account set name = #&#123;name&#125;, money = #&#123;money&#125; where id = #&#123;id&#125;\") int update(@Param(\"name\") String name, @Param(\"money\") double money, @Param(\"id\") int id); @Delete(\"delete from account where id = #&#123;id&#125;\") int delete(int id); @Select(\"select id, name, money from account where id = #&#123;id&#125;\") Account findAccount(@Param(\"id\") int id); @Select(\"select id, name, money from account\") List&lt;Account&gt; findAccountList();&#125; 使用xml 接口 123public interface AccountMapper2 &#123; int update( @Param(\"money\") double money, @Param(\"id\") int id);&#125; mapper 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.forezp.dao.AccountMapper2\"&gt; &lt;update id=\"update\"&gt; UPDATE account set money=#&#123;money&#125; WHERE id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; service层1234567891011121314@Servicepublic class AccountService2 &#123; @Autowired AccountMapper2 accountMapper2; //使用声明式事务 @Transactional public void transfer() throws RuntimeException&#123; accountMapper2.update(90,1);//用户1减10块 用户2加10块 int i=1/0; accountMapper2.update(110,2); &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"SpringBoot入门4：JPA","slug":"SpringBoot入门4：JPA","date":"2019-10-09T11:32:04.000Z","updated":"2020-06-04T00:57:09.297Z","comments":true,"path":"2019/10/09/SpringBoot入门4：JPA/","link":"","permalink":"https://wang-qp.github.io/2019/10/09/SpringBoot入门4：JPA/","excerpt":"","text":"JPA概述 JPA全称Java Persistence API.JPA通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。 JPA 的目标之一是制定一个可以由很多供应商实现的API，并且开发人员可以编码来实现该API，而不是使用私有供应商特有的API。 JPA是需要Provider来实现其功能的，Hibernate就是JPA Provider中很强的一个，应该说无人能出其右。从功能上来说，JPA就是Hibernate功能的一个子集。 实现添加相关依赖 添加spring-boot-starter-jdbc依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa &lt;/artifactId&gt;&lt;/dependency&gt; 添加mysql连接类和连接池类： 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 配置数据源，在application.properties文件配置：1234567891011spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8 username: root password: 123456 jpa: hibernate: ddl-auto: update # 第一次简表create 后面用update show-sql: true 注意，如果通过jpa在数据库中建表，将jpa.hibernate,ddl-auto改为create，建完表之后，要改为update,要不然每次重启工程会删除表并新建。实体类 通过@Entity 表明是一个映射的实体类， @Id表明id， @GeneratedValue 字段自动生成12345678@Entitypublic class Account &#123; @Id @GeneratedValue private int id ; private String name ; private double money;&#125; DAO层 数据访问层，通过编写一个继承自 JpaRepository 的接口就能完成数据访问,其中包含了几本的单表查询的方法，非常的方便。值得注意的是，这个Account 对象名，而不是具体的表名，另外Interger是主键的类型，一般为Integer或者Long12public interface AccountDao extends JpaRepository&lt;Account,Integer&gt; &#123;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"SpringBoot入门3：JDBCTemplate","slug":"SpringBoot入门3：JDBCTemplate","date":"2019-10-09T09:08:33.000Z","updated":"2020-06-04T00:57:09.296Z","comments":true,"path":"2019/10/09/SpringBoot入门3：JDBCTemplate/","link":"","permalink":"https://wang-qp.github.io/2019/10/09/SpringBoot入门3：JDBCTemplate/","excerpt":"","text":"JDBCTemplate创建工程引入依赖：在pom文件引入spring-boot-starter-jdbc的依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 引入mysql连接类和连接池：1234567891011&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.29&lt;/version&gt;&lt;/dependency&gt; 开启web:1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 配置相关文件在application.properties文件配置mysql的驱动类，数据库地址，数据库账号、密码信息。 1234spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://127.0.0.1:3306/springboot?serverTimezone=UTCspring.datasource.username=usernamespring.datasource.password=password 具体代码Dao实现类12345678910111213141516171819202122232425262728293031323334353637383940414243@Repositorypublic class AccountDaoImpl implements IAccountDAO &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public int add(Account account) &#123; String sql = \"insert into account(name,money) value(?,?)\"; return jdbcTemplate.update(sql,account.getName(),account.getMoney()); &#125; @Override public int update(Account account) &#123; String sql = \"update account set name=?,money=? where id=?\"; return jdbcTemplate.update(sql,account.getName(),account.getMoney(),account.getId()); &#125; @Override public int delete(int id) &#123; String sql = \"delete from teble account where id=?\"; return jdbcTemplate.update(sql,id); &#125; @Override public Account findAccountById(int id) &#123; String sql = \"select * from account where id=?\"; List&lt;Account&gt; list = jdbcTemplate.query(sql, new Object[]&#123;id&#125;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); if (list!=null &amp;&amp; list.size()&gt;0) &#123; return list.get(0); &#125; else &#123; return null; &#125; &#125; @Override public List&lt;Account&gt; findAccountList() &#123; List&lt;Account&gt; list = jdbcTemplate.query(\"select * from account\", new Object[]&#123;&#125;, new BeanPropertyRowMapper(Account.class)); if(list!=null &amp;&amp; list.size()&gt;0)&#123; return list; &#125;else&#123; return null; &#125; &#125;&#125; controller12345678910111213141516171819202122232425262728293031323334353637383940414243444546@RestController@RequestMapping(\"/account\")public class AccountController &#123; @Autowired IAccountService accountService; @RequestMapping(value = \"/list\",method = RequestMethod.GET) public List&lt;Account&gt; getAccounts()&#123; return accountService.findAccountList(); &#125; @RequestMapping(value = \"/&#123;id&#125;\",method = RequestMethod.GET) public Account getAccountById(@PathVariable(\"id\") int id)&#123; return accountService.findAccountById(id); &#125; @RequestMapping(value = \"/&#123;id&#125;\",method = RequestMethod.PUT) public String updateAccount(@PathVariable(\"id\")int id , @RequestParam(value = \"name\",required = true)String name, @RequestParam(value = \"money\" ,required = true)double money)&#123; Account account=new Account(); account.setMoney(money); account.setName(name); account.setId(id); int t=accountService.update(account); if(t==1)&#123; return account.toString(); &#125;else &#123; return \"fail\"; &#125; &#125; @RequestMapping(value = \"\",method = RequestMethod.POST) public String postAccount( @RequestParam(value = \"name\")String name, @RequestParam(value = \"money\" )double money)&#123; Account account=new Account(); account.setMoney(money); account.setName(name); int t= accountService.add(account); if(t==1)&#123; return account.toString(); &#125;else &#123; return \"fail\"; &#125; &#125;&#125; 可以通过postman来测试","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"SpringBoot入门2：配置文件","slug":"SpringBoot入门2：配置文件","date":"2019-10-09T07:49:53.000Z","updated":"2020-06-04T00:57:09.296Z","comments":true,"path":"2019/10/09/SpringBoot入门2：配置文件/","link":"","permalink":"https://wang-qp.github.io/2019/10/09/SpringBoot入门2：配置文件/","excerpt":"","text":"配置文件自定义属性 如果你需要读取配置文件的值只需要加@Value(“${属性名}”) 将配置文件的属性赋给实体类12345678my: name: forezp age: 12 number: $&#123;random.int&#125; uuid : $&#123;random.uuid&#125; max: $&#123;random.int(10)&#125; value: $&#123;random.value&#125; greeting: hi,i'm $&#123;my.name&#125; javabean123456789101112@ConfigurationProperties(prefix = \"my\")@Componentpublic class ConfigBean &#123; private String name; private int age; private int number; private String uuid; private int max; private String value; private String greeting;&#125; spring-boot-configuration-processor依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 应用类1234567891011@RestController@EnableConfigurationProperties(&#123;ConfigBean.class&#125;)public class LucyController &#123; @Autowired ConfigBean configBean; @RequestMapping(\"/lucy\") public String miya() &#123; return configBean.getGreeting()+\" &gt;&gt;&gt;&gt;\"+configBean.getName()+\" &gt;&gt;&gt;&gt;\"+ configBean.getUuid()+\" &gt;&gt;&gt;&gt;\"+configBean.getMax(); &#125;&#125; 自定义配置文件test.properties12com.wang.name=wangcom.wang.age=12 javaBean 在最新版本的springboot，需要加这三个注解。@Configuration @PropertySource(value = “classpath:test.properties”) @ConfigurationProperties(prefix = “com.forezp”);在1.4版本需要 PropertySource加上location。1234567891011121314151617181920212223@Configuration@PropertySource(\"test.properties\")@ConfigurationProperties(\"com.wang\")public class User &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 应用类123456789101112131415161718@RestController@EnableConfigurationProperties(&#123;ConfigBean.class,User.class&#125;)public class LucyController &#123; @Autowired ConfigBean configBean; @RequestMapping(\"/lucy\") public String miya() &#123; return configBean.getGreeting()+\" &gt;&gt;&gt;&gt;\"+configBean.getName()+\" &gt;&gt;&gt;&gt;\"+ configBean.getUuid()+\" &gt;&gt;&gt;&gt;\"+configBean.getMax(); &#125; @Autowired User user; @RequestMapping(\"/user\") public String user() &#123; return user.getName()+\"&gt;&gt;&gt;&gt;\"+user.getAge(); &#125;&#125; 多个环境配置文件 application-test.properties：测试环境 application-dev.properties：开发环境 application-prod.properties：生产环境 使用方法 application.yml 123spring: profiles: active: dev application-dev.yml 12server: port: 8082","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"SpringBoot入门1：创建工程","slug":"SpringBoot入门1：创建工程","date":"2019-10-09T06:30:43.000Z","updated":"2020-06-04T00:57:09.296Z","comments":true,"path":"2019/10/09/SpringBoot入门1：创建工程/","link":"","permalink":"https://wang-qp.github.io/2019/10/09/SpringBoot入门1：创建工程/","excerpt":"","text":"构建springboot工程创建项目 打开Idea-&gt; new Project -&gt;Spring Initializr -&gt;填写group、artifact -&gt;钩上web(开启web功能）-&gt;点下一步就行了。目录结构 pom文件为基本的依赖管理文件 resouces 资源文件 statics 静态资源 templates 模板资源 application.yml 配置文件 SpringbootApplication程序的入口。启动springboot 方式 cd到项目主目录: mvn clean mvn package 编译项目的jar mvn spring-boot: run 启动 cd 到target目录，java -jar 项目.jar单元测试 通过@RunWith() @SpringBootTest开启注解123456789101112131415161718192021222324@RunWith(SpringRunner.class)@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)public class HelloControllerIT &#123; @LocalServerPort private int port; private URL base; @Autowired private TestRestTemplate template; @Before public void setUp() throws Exception &#123; this.base = new URL(\"http://localhost:\" + port + \"/\"); &#125; @Test public void getHello() throws Exception &#123; ResponseEntity&lt;String&gt; response = template.getForEntity(base.toString(), String.class); assertThat(response.getBody(), equalTo(\"Greetings from Spring Boot!\")); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"ssm框架整合","slug":"ssm框架整合","date":"2019-09-15T14:35:31.000Z","updated":"2020-06-04T00:57:09.310Z","comments":true,"path":"2019/09/15/ssm框架整合/","link":"","permalink":"https://wang-qp.github.io/2019/09/15/ssm框架整合/","excerpt":"","text":"ssm框架整合步骤* 1. 先搭建整合的环境 * 2. 先把Spring的配置搭建完成 * 3. 再使用Spring整合SpringMVC框架 * 4. 最后使用Spring整合MyBatis框架数据库1234567create database ssm;use ssm;create table account( id int primary key auto_increment, name varchar(20), money double); pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; web.xml123456789101112131415161718192021222324252627282930313233343536373839404142&lt;web-app&gt;&lt;!--配置Spring的监听器，默认只加载WEB-INF目录下的applicationContext.xml配置文件--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--设置配置文件的路径--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--加载springmvc.xml配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动服务器，创建该servlet--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--解决中文乱码的过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; applicationContext.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!-- 开启注解扫描，要扫描的是service和dao层的注解，要忽略web层注解，因为web层让SpringMVC框架去管理 --&gt; &lt;context:component-scan base-package=\"cn.wang\"&gt; &lt;!-- 配置要忽略的注解 --&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt; &lt;!--Spring整合MyBatis框架--&gt; &lt;!--配置连接池--&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql:///ssm\"/&gt; &lt;property name=\"user\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/bean&gt; &lt;!--配置SqlSessionFactory工厂--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!--配置AccountDao接口所在包--&gt; &lt;bean id=\"mapperScanner\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"cn.wang.dao\"/&gt; &lt;/bean&gt; &lt;!--配置Spring框架声明式事务管理--&gt; &lt;!--配置事务管理器--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!--配置事务通知--&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"find*\" read-only=\"true\"/&gt; &lt;tx:method name=\"*\" isolation=\"DEFAULT\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置AOP增强--&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* cn.wang.service.impl.*ServiceImpl.*(..))\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; springmvc.xml12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 扫描controller的注解，别的不扫描 --&gt; &lt;context:component-scan base-package=\"cn.wang\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- JSP文件所在的目录 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\" /&gt; &lt;!-- 文件的后缀名 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;!-- 设置静态资源不过滤 --&gt; &lt;mvc:resources location=\"/css/\" mapping=\"/css/**\" /&gt; &lt;mvc:resources location=\"/images/\" mapping=\"/images/**\" /&gt; &lt;mvc:resources location=\"/js/\" mapping=\"/js/**\" /&gt; &lt;!-- 开启对SpringMVC注解的支持 --&gt; &lt;mvc:annotation-driven /&gt;&lt;/beans&gt; dao12345678910@Repositorypublic interface AccountDao &#123; //查询所有账户 @Select(\"select * from account\") public List&lt;Account&gt; findAll(); //保存账户信息 @Insert(\"insert into account (name,money) value(#&#123;name&#125;,#&#123;money&#125;)\") public void saveAccount(Account account);&#125; ServiceImpl1234567891011121314151617@Service(\"accountService\")public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao dao; @Override public List&lt;Account&gt; findAll() &#123; System.out.println(\"业务层：查询所有\"); return dao.findAll(); &#125; @Override public void saveAccount(Account account) &#123; System.out.println(\"业务层：保存帐户\"); dao.saveAccount(account); &#125;&#125; Controller123456789101112131415161718192021@Controller@RequestMapping(\"/account\")public class AccountController &#123; @Autowired private AccountService accountService; @RequestMapping(\"/findAll\") public String findAll(Model model) &#123; System.out.println(\"表现层：查询所有\"); List&lt;Account&gt; list = accountService.findAll(); model.addAttribute(\"list\",list); return \"list\"; &#125; @RequestMapping(\"/save\") public void save(Account account, HttpServletRequest request, HttpServletResponse response) throws IOException &#123; accountService.saveAccount(account); response.sendRedirect(request.getContextPath()+\"/account/findAll\"); return ; &#125;&#125; index.jsp1234567&lt;a href=\"account/findAll\"&gt;测试&lt;/a&gt;&lt;form action=\"account/save\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"name\" /&gt;&lt;br&gt; 金额：&lt;input type=\"text\" name=\"money\" /&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; list.jsp12345678910111213&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %&gt;&lt;%@taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;查询所有账户&lt;/h3&gt; &lt;c:forEach items=\"$&#123;list&#125;\" var=\"account\"&gt; $&#123;account.name&#125; &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"SpringMVC入门4","slug":"SpringMVC入门4","date":"2019-09-14T13:38:55.000Z","updated":"2020-06-04T00:57:09.301Z","comments":true,"path":"2019/09/14/SpringMVC入门4/","link":"","permalink":"https://wang-qp.github.io/2019/09/14/SpringMVC入门4/","excerpt":"","text":"异常处理和拦截器 异常处理器异常处理思路 Controller调用service，service调用dao，异常都是向上抛出的，最终有DispatcherServlet找异常处理器进行异常的处理。自定义异常类1234567891011121314public class SysException extends Exception&#123; private static final long serialVersionUID = 4055945147128016300L; // 异常提示信息 private String message; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public SysException(String message) &#123; this.message = message; &#125;&#125; 自定义异常处理器12345678910111213141516171819202122232425/*** 异常处理器* @author rt*/public class SysExceptionResolver implements HandlerExceptionResolver&#123;/*** 跳转到具体的错误页面的方法*/public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler,Exception ex) &#123; ex.printStackTrace(); SysException e = null; // 获取到异常对象 if(ex instanceof SysException) &#123; e = (SysException) ex; &#125;else &#123; e = new SysException(\"请联系管理员\"); &#125; ModelAndView mv = new ModelAndView(); // 存入错误的提示信息 mv.addObject(\"message\", e.getMessage()); // 跳转的Jsp页面 mv.setViewName(\"error\"); return mv; &#125;&#125; 配置异常处理器12&lt;!-- 配置异常处理器 --&gt;&lt;bean id=\"sysExceptionResolver\" class=\"cn.itcast.exception.SysExceptionResolver\"/&gt; 拦截器拦截器的概述 SpringMVC框架中的拦截器用于对处理器进行预处理和后处理的技术。 可以定义拦截器链，连接器链就是将拦截器按着一定的顺序结成一条链，在访问被拦截的方法时，拦截器链中的拦截器会按着定义的顺序执行。 拦截器和过滤器的功能比较类似，有区别 过滤器是Servlet规范的一部分，任何框架都可以使用过滤器技术。 拦截器是SpringMVC框架独有的。 过滤器配置了/*，可以拦截任何资源。 拦截器只会对控制器中的方法进行拦截。 拦截器也是AOP思想的一种实现方式 想要自定义拦截器，需要实现HandlerInterceptor接口。代码实现 创建类，实现HandlerInterceptor接口，重写需要的方法 12345678910111213141516/*** 自定义拦截器1* @author rt*/public class MyInterceptor1 implements HandlerInterceptor&#123; /** * controller方法执行前，进行拦截的方法 * return true放行 * return false拦截 * 可以使用转发或者重定向直接跳转到指定的页面。 */ public boolean preHandle(HttpServletRequest request, HttpServletResponse response,Object handler) throws Exception &#123; System.out.println(\"拦截器执行了...\"); return true; &#125;&#125; 在springmvc.xml中配置拦截器类 123456789101112&lt;!-- 配置拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 哪些方法进行拦截 --&gt; &lt;mvc:mapping path=\"/user/*\"/&gt; &lt;!-- 哪些方法不进行拦截 &lt;mvc:exclude-mapping path=\"\"/&gt; --&gt; &lt;!-- 注册拦截器对象 --&gt; &lt;bean class=\"cn.itcast.demo1.MyInterceptor1\"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; HandlerInterceptor接口中的方法 preHandle方法是controller方法执行前拦截的方法 可以使用request或者response跳转到指定的页面 return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。 return false不放行，不会执行controller中的方法。 postHandle是controller方法执行后执行的方法，在JSP视图执行前。 可以使用request或者response跳转到指定的页面 如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。 postHandle方法是在JSP执行后执行 request或者response不能再跳转页面了","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"SpringMVC入门3","slug":"SpringMVC入门3","date":"2019-09-14T12:07:24.000Z","updated":"2020-06-04T00:57:09.301Z","comments":true,"path":"2019/09/14/SpringMVC入门3/","link":"","permalink":"https://wang-qp.github.io/2019/09/14/SpringMVC入门3/","excerpt":"","text":"文件上传 普通方式jar包12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; 上传页面12345&lt;h3&gt;文件上传&lt;/h3&gt;&lt;form action=\"user/fileupload\" method=\"post\" enctype=\"multipart/form-data\"&gt;选择文件：&lt;input type=\"file\" name=\"upload\"/&gt;&lt;br/&gt;&lt;input type=\"submit\" value=\"上传文件\"/&gt;&lt;/form&gt; Controller控制器1234567891011121314151617181920212223242526272829303132333435/*** 文件上传* @throws Exception*/@RequestMapping(value=\"/fileupload\")public String fileupload(HttpServletRequest request) throws Exception &#123; // 先获取到要上传的文件目录 String path = request.getSession().getServletContext().getRealPath(\"/uploads\"); // 创建File对象，一会向该路径下上传文件 File file = new File(path); // 判断路径是否存在，如果不存在，创建该路径 if(!file.exists()) &#123; file.mkdirs(); &#125; // 创建磁盘文件项工厂 DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload fileUpload = new ServletFileUpload(factory); // 解析request对象 List&lt;FileItem&gt; list = fileUpload.parseRequest(request); // 遍历 for (FileItem fileItem : list) &#123; // 判断文件项是普通字段，还是上传的文件 if(fileItem.isFormField()) &#123; &#125;else &#123; // 上传文件项 // 获取到上传文件的名称 String filename = fileItem.getName(); // 上传文件 fileItem.write(new File(file, filename)); // 删除临时文件 fileItem.delete(); &#125; &#125; return \"success\";&#125; SpringMVC传统方式上传文件 SpringMVC框架提供了MultipartFile对象，该对象表示上传的文件，要求变量名称必须和表单file标签的name属性名称相同。 代码如下文件解析器12345&lt;!-- 配置文件解析器对象，要求id名称必须是multipartResolver --&gt;&lt;bean id=\"multipartResolver\"class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt;&lt;property name=\"maxUploadSize\" value=\"10485760\"/&gt;&lt;/bean&gt; Controller控制器123456789101112131415161718192021222324252627/*** SpringMVC方式的文件上传** @param request* @return* @throws Exception*/@RequestMapping(value=\"/fileupload2\")public String fileupload2(HttpServletRequest request,MultipartFile upload) throws Exception &#123; System.out.println(\"SpringMVC方式的文件上传...\"); // 先获取到要上传的文件目录 String path = request.getSession().getServletContext().getRealPath(\"/uploads\"); // 创建File对象，一会向该路径下上传文件 File file = new File(path); // 判断路径是否存在，如果不存在，创建该路径 if(!file.exists()) &#123; file.mkdirs(); &#125; // 获取到上传文件的名称 String filename = upload.getOriginalFilename(); String uuid = UUID.randomUUID().toString().replaceAll(\"-\", \"\").toUpperCase(); // 把文件的名称唯一化 filename = uuid+\"_\"+filename; // 上传文件 upload.transferTo(new File(file,filename)); return \"success\";&#125; SpringMVC跨服务器上传文件jar包12345678910&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt; 上传页面12345&lt;h3&gt;跨服务器的文件上传&lt;/h3&gt;&lt;form action=\"user/fileupload3\" method=\"post\" enctype=\"multipart/form-data\"&gt;选择文件：&lt;input type=\"file\" name=\"upload\"/&gt;&lt;br/&gt;&lt;input type=\"submit\" value=\"上传文件\"/&gt;&lt;/form&gt; Controller控制器1234567891011121314151617181920212223242526/*** SpringMVC跨服务器方式的文件上传** @param request* @return* @throws Exception*/@RequestMapping(value=\"/fileupload3\")public String fileupload3(MultipartFile upload) throws Exception &#123; System.out.println(\"SpringMVC跨服务器方式的文件上传...\"); // 定义图片服务器的请求路径 String path = \"http://localhost:9090/day02_springmvc5_02image/uploads/\"; // 获取到上传文件的名称 String filename = upload.getOriginalFilename(); String uuid = UUID.randomUUID().toString().replaceAll(\"-\", \"\").toUpperCase(); // 把文件的名称唯一化 filename = uuid+\"_\"+filename; // 向图片服务器上传文件 // 创建客户端对象 Client client = Client.create(); // 连接图片服务器 WebResource webResource = client.resource(path+filename); // 上传文件 webResource.put(upload.getBytes()); return \"success\";&#125;","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"SpringMVC入门2","slug":"SpringMVC入门2","date":"2019-09-12T13:35:02.000Z","updated":"2020-06-04T00:57:09.300Z","comments":true,"path":"2019/09/12/SpringMVC入门2/","link":"","permalink":"https://wang-qp.github.io/2019/09/12/SpringMVC入门2/","excerpt":"","text":"常用的注解 RequestParam 作用：把请求中的指定名称的参数传递给控制器中的形参赋值 属性 value：请求参数中的名称 required：请求参数中是否必须提供此参数，默认值是true，必须提供 代码如下12345678910/*** 接收请求* @return*/@RequestMapping(path=\"/hello\")public String sayHello(@RequestParam(value=\"username\",required=false)String name) &#123; System.out.println(\"aaaa\"); System.out.println(name); return \"success\";&#125; RequestBody 作用：用于获取请求体的内容（注意：get方法不可以） 属性 required：是否必须有请求体，默认值是true 代码如下12345678910/*** 接收请求* @return*/@RequestMapping(path=\"/hello\")public String sayHello(@RequestBody String body) &#123; System.out.println(\"aaaa\"); System.out.println(body); return \"success\";&#125; PathVariable 作用：拥有绑定url中的占位符的。例如：url中有/delete/{id}，{id}就是占位符 属性 value：指定url中的占位符名称 Restful风格的URL 请求路径一样，可以根据不同的请求方式去执行后台的不同方法 restful风格的URL优点 结构清晰 符合标准 易于理解 扩展方便 代码如下1234567891011&lt;a href=\"user/hello/1\"&gt;入门案例&lt;/a&gt;``` ```java/*** 接收请求* @return*/@RequestMapping(path=\"/hello/&#123;id&#125;\")public String sayHello(@PathVariable(value=\"id\") String id) &#123; System.out.println(id); return \"success\";&#125; RequestHeader 作用：获取指定请求头的值 属性 value：请求头的名称 代码如下12345@RequestMapping(path=\"/hello\")public String sayHello(@RequestHeader(value=\"Accept\") String header) &#123; System.out.println(header); return \"success\";&#125; CookieValue 作用：用于获取指定cookie的名称的值 属性 value：cookie的名称 代码12345@RequestMapping(path=\"/hello\")public String sayHello(@CookieValue(value=\"JSESSIONID\") String cookieValue) &#123; System.out.println(cookieValue); return \"success\";&#125; ModelAttribute 作用 出现在方法上：表示当前方法会在控制器方法执行前线执行。 出现在参数上：获取指定的数据给参数赋值。 应用场景 当提交表单数据不是完整的实体数据时，保证没有提交的字段使用数据库原来的数据。 具体的代码 修饰的方法有返回值12345678910111213141516171819202122232425/*** 作用在方法，先执行* @param name* @return*/@ModelAttributepublic User showUser(String name) &#123; System.out.println(\"showUser执行了...\"); // 模拟从数据库中查询对象 User user = new User(); user.setName(\"哈哈\"); user.setPassword(\"123\"); user.setMoney(100d); return user;&#125;/*** 修改用户的方法* @param cookieValue* @return*/@RequestMapping(path=\"/updateUser\")public String updateUser(User user) &#123; System.out.println(user); return \"success\";&#125; 修饰的方法没有返回值12345678910111213141516171819202122232425/*** 作用在方法，先执行* @param name* @return*/@ModelAttributepublic void showUser(String name,Map&lt;String, User&gt; map) &#123; System.out.println(\"showUser执行了...\"); // 模拟从数据库中查询对象 User user = new User(); user.setName(\"哈哈\"); user.setPassword(\"123\"); user.setMoney(100d); map.put(\"abc\", user);&#125;/*** 修改用户的方法* @param cookieValue* @return*/@RequestMapping(path=\"/updateUser\") public String updateUser(@ModelAttribute(value=\"abc\") User user) &#123; System.out.println(user); return \"success\";&#125; SessionAttributes 作用：用于多次执行控制器方法间的参数共享 属性 value：指定存入属性的名称 代码如下1234567891011121314151617181920212223242526272829303132333435363738@Controller@RequestMapping(path=\"/user\")@SessionAttributes(value= &#123;\"username\",\"password\",\"age\"&#125;,types=&#123;String.class,Integer.class&#125;) // 把数据存入到session域对象中public class HelloController &#123;/*** 向session中存入值* @return*/@RequestMapping(path=\"/save\")public String save(Model model) &#123; System.out.println(\"向session域中保存数据\"); model.addAttribute(\"username\", \"root\"); model.addAttribute(\"password\", \"123\"); model.addAttribute(\"age\", 20); return \"success\";&#125;/*** 从session中获取值* @return*/@RequestMapping(path=\"/find\")public String find(ModelMap modelMap) &#123; String username = (String) modelMap.get(\"username\"); String password = (String) modelMap.get(\"password\"); Integer age = (Integer) modelMap.get(\"age\"); System.out.println(username + \" : \"+password +\" : \"+age); return \"success\";&#125;/*** 清除值* @return*/@RequestMapping(path=\"/delete\")public String delete(SessionStatus status) &#123; status.setComplete(); return \"success\"; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"SpringMVC入门1","slug":"SpringMVC入门1","date":"2019-09-11T07:28:20.000Z","updated":"2020-06-04T00:57:09.300Z","comments":true,"path":"2019/09/11/SpringMVC入门1/","link":"","permalink":"https://wang-qp.github.io/2019/09/11/SpringMVC入门1/","excerpt":"","text":"SpringMVC创建 maven.xml1234567891011121314151617181920212223242526272829303132&lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; web.xml12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"2.4\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"&gt;&lt;!-- 配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:SpringMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;!-- 配置中文过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; SpringMVC.xml(配置)1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=\"cn.wang\"&gt;&lt;/context:component-scan&gt; &lt;!-- 视图解析器对象 --&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!-- 配置自定义类型转换器 --&gt; &lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;set&gt; &lt;bean class=\"cn.wang.utils.StringToDateConverter\"/&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 设置静态资源不过滤 --&gt; &lt;mvc:resources location=\"/css/\" mapping=\"/css/**\"/&gt; &lt;!-- 样式 --&gt; &lt;mvc:resources location=\"/images/\" mapping=\"/images/**\"/&gt; &lt;!-- 图片 --&gt; &lt;mvc:resources location=\"/js/\" mapping=\"/js/**\"/&gt; &lt;!-- javascript --&gt;&lt;!-- 开启SpringMVC框架注解的支持--&gt; &lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt;&lt;/beans&gt; Controller123456789101112131415161718192021222324252627@Controllerpublic class HelloController &#123; @RequestMapping(path = \"/hello\",params = &#123;&#125;,headers = &#123;&#125;) public String sayHello()&#123; System.out.println(\"Hello\"); return \"success\"; &#125; /** * 原生的API * @return */ @RequestMapping(\"/testServlet\") public String testServlet(HttpServletRequest request, HttpServletResponse response)&#123; System.out.println(\"执行了...\"); System.out.println(request); HttpSession session = request.getSession(); System.out.println(session); ServletContext servletContext = session.getServletContext(); System.out.println(servletContext); System.out.println(response); return \"success\"; &#125;&#125; 类型转换器12345678910111213141516171819202122232425/** * 把字符串转换日期 */public class StringToDateConverter implements Converter&lt;String,Date&gt;&#123; /** * String source 传入进来字符串 * @param source * @return */ public Date convert(String source) &#123; // 判断 if(source == null)&#123; throw new RuntimeException(\"请您传入数据\"); &#125; DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\"); try &#123; // 把字符串转换日期 return df.parse(source); &#125; catch (Exception e) &#123; throw new RuntimeException(\"数据类型转换出现错误\"); &#125; &#125;&#125; json 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"Spring入门8","slug":"Spring入门8","date":"2019-08-19T12:24:34.000Z","updated":"2020-06-04T00:57:09.304Z","comments":true,"path":"2019/08/19/Spring入门8/","link":"","permalink":"https://wang-qp.github.io/2019/08/19/Spring入门8/","excerpt":"","text":"Spring(事务控制)使用纯注解 maven.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 主配置类12345678910/** * spring的配置类，相当于bean.xml */@Configuration@ComponentScan(\"com.itheima\")@Import(&#123;JdbcConfig.class,TransactionConfig.class&#125;)@PropertySource(\"jdbcConfig.properties\")@EnableTransactionManagementpublic class SpringConfiguration &#123;&#125; jdbc配置类1234567891011121314151617181920212223242526272829303132333435363738394041/** * 和连接数据库相关的配置类 */public class JdbcConfig &#123; @Value(\"$&#123;jdbc.driver&#125;\") private String driver; @Value(\"$&#123;jdbc.url&#125;\") private String url; @Value(\"$&#123;jdbc.username&#125;\") private String username; @Value(\"$&#123;jdbc.password&#125;\") private String password; /** * 创建JdbcTemplate * @param dataSource * @return */ @Bean(name=\"jdbcTemplate\") public JdbcTemplate createJdbcTemplate(DataSource dataSource)&#123; return new JdbcTemplate(dataSource); &#125; /** * 创建数据源对象 * @return */ @Bean(name=\"dataSource\") public DataSource createDataSource()&#123; DriverManagerDataSource ds = new DriverManagerDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(username); ds.setPassword(password); return ds; &#125;&#125; 事务配置类123456789101112131415/** * 和事务相关的配置类 */public class TransactionConfig &#123; /** * 用于创建事务管理器对象 * @param dataSource * @return */ @Bean(name=\"transactionManager\") public PlatformTransactionManager createTransactionManager(DataSource dataSource)&#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; service123456789101112131415161718192021222324252627282930313233343536373839404142/** * 账户的业务层实现类 * * 事务控制应该都是在业务层 */@Service(\"accountService\")@Transactional(propagation= Propagation.SUPPORTS,readOnly=true)//只读型事务的配置public class AccountServiceImpl implements IAccountService&#123; @Autowired private IAccountDao accountDao; @Override public Account findAccountById(Integer accountId) &#123; return accountDao.findAccountById(accountId); &#125; //需要的是读写型事务配置 @Transactional(propagation= Propagation.REQUIRED,readOnly=false) @Override public void transfer(String sourceName, String targetName, Float money) &#123; System.out.println(\"transfer....\"); //2.1根据名称查询转出账户 Account source = accountDao.findAccountByName(sourceName); //2.2根据名称查询转入账户 Account target = accountDao.findAccountByName(targetName); //2.3转出账户减钱 source.setMoney(source.getMoney()-money); //2.4转入账户加钱 target.setMoney(target.getMoney()+money); //2.5更新转出账户 accountDao.updateAccount(source);// int i=1/0; //2.6更新转入账户 accountDao.updateAccount(target); &#125;&#125; 测试类1234567891011121314/** * 使用Junit单元测试：测试我们的配置 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes= SpringConfiguration.class)public class AccountServiceTest &#123; @Autowired private IAccountService as; @Test public void testTransfer()&#123; as.transfer(\"aaa\",\"bbb\",100f); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"Spring入门7","slug":"Spring入门7","date":"2019-08-19T08:06:43.000Z","updated":"2020-06-04T00:57:09.304Z","comments":true,"path":"2019/08/19/Spring入门7/","link":"","permalink":"https://wang-qp.github.io/2019/08/19/Spring入门7/","excerpt":"","text":"Spring(事务控制)使用注解+xml maven.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; bean.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置spring创建容器时要扫描的包--&gt; &lt;context:component-scan base-package=\"com.itheima\"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置JdbcTemplate--&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源--&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/java\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring中基于注解 的声明式事务控制配置步骤 1、配置事务管理器 2、开启spring对注解事务的支持 3、在需要事务支持的地方使用@Transactional注解 --&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启spring对注解事务的支持--&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\"&gt;&lt;/tx:annotation-driven&gt;&lt;/beans&gt; service12345678910111213141516171819202122232425262728293031323334@Service(\"accountService\")@Transactional(propagation= Propagation.SUPPORTS,readOnly=true)//只读型事务的配置public class AccountServiceImpl implements IAccountService&#123; @Autowired private IAccountDao accountDao; @Override public Account findAccountById(Integer accountId) &#123; return accountDao.findAccountById(accountId); &#125; //需要的是读写型事务配置 @Transactional(propagation= Propagation.REQUIRED,readOnly=false) @Override public void transfer(String sourceName, String targetName, Float money) &#123; System.out.println(\"transfer....\"); //2.1根据名称查询转出账户 Account source = accountDao.findAccountByName(sourceName); //2.2根据名称查询转入账户 Account target = accountDao.findAccountByName(targetName); //2.3转出账户减钱 source.setMoney(source.getMoney()-money); //2.4转入账户加钱 target.setMoney(target.getMoney()+money); //2.5更新转出账户 accountDao.updateAccount(source); int i=1/0; //2.6更新转入账户 accountDao.updateAccount(target); &#125;&#125; dao1234567891011121314151617181920212223242526272829@Repository(\"accountDao\")public class AccountDaoImpl implements IAccountDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public Account findAccountById(Integer accountId) &#123; List&lt;Account&gt; accounts = jdbcTemplate.query(\"select * from account where id = ?\",new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountId); return accounts.isEmpty()?null:accounts.get(0); &#125; @Override public Account findAccountByName(String accountName) &#123; List&lt;Account&gt; accounts = jdbcTemplate.query(\"select * from account where name = ?\",new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountName); if(accounts.isEmpty())&#123; return null; &#125; if(accounts.size()&gt;1)&#123; throw new RuntimeException(\"结果集不唯一\"); &#125; return accounts.get(0); &#125; @Override public void updateAccount(Account account) &#123; jdbcTemplate.update(\"update account set name=?,money=? where id=?\",account.getName(),account.getMoney(),account.getId()); &#125;&#125; 测试类1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:bean.xml\")public class AccountServiceTest &#123; @Autowired private IAccountService as; @Test public void testTransfer()&#123; as.transfer(\"aaa\",\"bbb\",100f); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"Spring入门6","slug":"Spring入门6","date":"2019-08-17T09:51:06.000Z","updated":"2020-06-04T00:57:09.303Z","comments":true,"path":"2019/08/17/Spring入门6/","link":"","permalink":"https://wang-qp.github.io/2019/08/17/Spring入门6/","excerpt":"","text":"Spring(事务控制)使用xml maven.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; bean.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 配置业务层--&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置账户的持久层--&gt; &lt;bean id=\"accountDao\" class=\"com.itheima.dao.impl.AccountDaoImpl\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源--&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/java\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring中基于XML的声明式事务控制配置步骤 1、配置事务管理器 2、配置事务的通知 此时我们需要导入事务的约束 tx名称空间和约束，同时也需要aop的 使用tx:advice标签配置事务通知 属性： id：给事务通知起一个唯一标识 transaction-manager：给事务通知提供一个事务管理器引用 3、配置AOP中的通用切入点表达式 4、建立事务通知和切入点表达式的对应关系 5、配置事务的属性 是在事务的通知tx:advice标签的内部 --&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务的通知--&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;!-- 配置事务的属性 isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔离级别。 propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。 read-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是false，表示读写。 timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，以秒为单位。 rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。 no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"false\"/&gt; &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"&gt;&lt;/tx:method&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置aop--&gt; &lt;aop:config&gt; &lt;!-- 配置切入点表达式--&gt; &lt;aop:pointcut id=\"pt1\" expression=\"execution(* com.itheima.service.impl.*.*(..))\"&gt;&lt;/aop:pointcut&gt; &lt;!--建立切入点表达式和事务通知的对应关系 --&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pt1\"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试类1234567891011121314/** * 使用Junit单元测试：测试我们的配置 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:bean.xml\")public class AccountServiceTest &#123; @Autowired private IAccountService as; @Test public void testTransfer()&#123; as.transfer(\"aaa\",\"bbb\",100f); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"Spring入门5","slug":"Spring入门5","date":"2019-08-16T09:30:15.000Z","updated":"2020-06-04T00:57:09.303Z","comments":true,"path":"2019/08/16/Spring入门5/","link":"","permalink":"https://wang-qp.github.io/2019/08/16/Spring入门5/","excerpt":"","text":"Spring(AOP)使用注解 maven123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; bean.xml12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"cn.wang\"&gt;&lt;/context:component-scan&gt; &lt;bean id=\"logger\" class=\"cn.wang.utils.Logger\"&gt;&lt;/bean&gt; &lt;!--配置Spring开始注解AOP的支持--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt; 通知类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@Component(\"logger\")@Aspect//表示当前类是切面类public class Logger &#123; @Pointcut(\"execution(* cn.wang.service.impl.*.*(..))\") private void pt1()&#123;&#125; /** * 前置通知 */// @Before(\"pt1()\") public void beforePrintLog()&#123; System.out.println(\"前置通知Logger类中的beforePrintLog方法开始记录日志了。。。\"); &#125; /** * 后置通知 */// @AfterReturning(\"pt1()\") public void afterReturningPrintLog()&#123; System.out.println(\"后置通知Logger类中的afterReturningPrintLog方法开始记录日志了。。。\"); &#125; /** * 异常通知 */// @AfterThrowing(\"pt1()\") public void afterThrowingPrintLog()&#123; System.out.println(\"异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了。。。\"); &#125; /** * 最终通知 */// @After(\"pt1()\") public void afterPrintLog()&#123; System.out.println(\"最终通知Logger类中的afterPrintLog方法开始记录日志了。。。\"); &#125; /** * 环绕通知 * 问题： * 当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。 * 分析： * 通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。 * 解决： * Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。 * 该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。 * * spring中的环绕通知： * 它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。 */ @Around(\"pt1()\") public Object aroundPringLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try&#123; Object[] args = pjp.getArgs();//得到方法执行所需的参数 System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。前置\"); rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法） System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。后置\"); return rtValue; &#125;catch (Throwable t)&#123; System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。异常\"); throw new RuntimeException(t); &#125;finally &#123; System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。最终\"); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"Spring入门4","slug":"Spring入门4","date":"2019-08-15T13:52:19.000Z","updated":"2020-06-04T00:57:09.302Z","comments":true,"path":"2019/08/15/Spring入门4/","link":"","permalink":"https://wang-qp.github.io/2019/08/15/Spring入门4/","excerpt":"","text":"Spring(AOP)使用xml maven123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; bean.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--配置Spring的Ioc，把service对象配置进来--&gt; &lt;bean id=\"accountService\" class=\"cn.wang.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt; &lt;bean id=\"logger\" class=\"cn.wang.utils.Logger\"&gt;&lt;/bean&gt; &lt;!--spring中基于XML的AOP配置步骤 1、把通知Bean也交给spring来管理 2、使用aop:config标签表明开始AOP的配置 3、使用aop:aspect标签表明配置切面 id属性：是给切面提供一个唯一标识 ref属性：是指定通知类bean的Id。 4、在aop:aspect标签的内部使用对应标签来配置通知的类型 我们现在示例是让printLog方法在切入点方法执行之前之前：所以是前置通知 aop:before：表示配置前置通知 method属性：用于指定Logger类中哪个方法是前置通知 pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强 切入点表达式的写法： 关键字：execution(表达式) 表达式： 访问修饰符 返回值 包名.包名.包名...类名.方法名(参数列表) 标准的表达式写法： public void com.itheima.service.impl.AccountServiceImpl.saveAccount() 访问修饰符可以省略 void com.itheima.service.impl.AccountServiceImpl.saveAccount() 返回值可以使用通配符，表示任意返回值 * com.itheima.service.impl.AccountServiceImpl.saveAccount() 包名可以使用通配符，表示任意包。但是有几级包，就需要写几个*. * *.*.*.*.AccountServiceImpl.saveAccount()) 包名可以使用..表示当前包及其子包 * *..AccountServiceImpl.saveAccount() 类名和方法名都可以使用*来实现通配 * *..*.*() 参数列表： 可以直接写数据类型： 基本类型直接写名称 int 引用类型写包名.类名的方式 java.lang.String 可以使用通配符表示任意类型，但是必须有参数 可以使用..表示有无参数均可，有参数可以是任意类型 全通配写法： * *..*.*(..) 实际开发中切入点表达式的通常写法： 切到业务层实现类下的所有方法 * com.itheima.service.impl.*.*(..) --&gt; &lt;!--配置AOP--&gt; &lt;aop:config&gt; &lt;!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容 此标签写在aop:aspect标签内部只能当前切面使用。 它还可以写在aop:aspect外面，此时就变成了所有切面可用 --&gt; &lt;aop:pointcut id=\"pt1\" expression=\"execution(* cn.wang.service.impl.*.*(..))\"&gt;&lt;/aop:pointcut&gt; &lt;!--配置切面 --&gt; &lt;aop:aspect id=\"logAdvice\" ref=\"logger\"&gt; &lt;!-- 配置前置通知：在切入点方法执行之前执行 &lt;aop:before method=\"beforePrintLog\" pointcut-ref=\"pt1\" &gt;&lt;/aop:before&gt;--&gt; &lt;!-- 配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个 &lt;aop:after-returning method=\"afterReturningPrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:after-returning&gt;--&gt; &lt;!-- 配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个 &lt;aop:after-throwing method=\"afterThrowingPrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:after-throwing&gt;--&gt; &lt;!-- 配置最终通知：无论切入点方法是否正常执行它都会在其后面执行 &lt;aop:after method=\"afterPrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:after&gt;--&gt; &lt;!-- 配置环绕通知 详细的注释请看Logger类中--&gt; &lt;aop:around method=\"aroundPringLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 通知类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Logger &#123; /** * 前置通知 */ public void beforePrintLog()&#123; System.out.println(\"前置通知Logger类中的beforePrintLog方法开始记录日志了。。。\"); &#125; /** * 后置通知 */ public void afterReturningPrintLog()&#123; System.out.println(\"后置通知Logger类中的afterReturningPrintLog方法开始记录日志了。。。\"); &#125; /** * 异常通知 */ public void afterThrowingPrintLog()&#123; System.out.println(\"异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了。。。\"); &#125; /** * 最终通知 */ public void afterPrintLog()&#123; System.out.println(\"最终通知Logger类中的afterPrintLog方法开始记录日志了。。。\"); &#125; /** * 环绕通知 * 问题： * 当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。 * 分析： * 通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。 * 解决： * Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。 * 该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。 * * spring中的环绕通知： * 它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。 */ public Object aroundPringLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try&#123; Object[] args = pjp.getArgs();//得到方法执行所需的参数 System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。前置\"); rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法） System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。后置\"); return rtValue; &#125;catch (Throwable t)&#123; System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。异常\"); throw new RuntimeException(t); &#125;finally &#123; System.out.println(\"Logger类中的aroundPringLog方法开始记录日志了。。。最终\"); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"动态代理","slug":"动态代理","date":"2019-08-14T15:11:46.000Z","updated":"2020-06-04T00:57:09.311Z","comments":true,"path":"2019/08/14/动态代理/","link":"","permalink":"https://wang-qp.github.io/2019/08/14/动态代理/","excerpt":"","text":"为什么要用代理* 最主要的原因就是，在不改变目标对象方法的情况下对方法进行增强。 * 比如，我们希望对方法的调用增加日志记录，或者对方法的调用进行拦截，等等...基于接口的动态代理接口1234567891011121314public interface IProducer &#123; /** * 销售 * @param money */ public void saleProduct(float money); /** * 售后 * @param money */ public void afterService(float money);&#125; 实现类123456789101112131415161718public class Producer implements IProducer&#123; /** * 销售 * @param money */ public void saleProduct(float money)&#123; System.out.println(\"销售产品，并拿到钱：\"+money); &#125; /** * 售后 * @param money */ public void afterService(float money)&#123; System.out.println(\"提供售后服务，并拿到钱：\"+money); &#125;&#125; 测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Client &#123; public static void main(String[] args) &#123; final Producer producer = new Producer(); /** * 动态代理： * 特点：字节码随用随创建，随用随加载 * 作用：不修改源码的基础上对方法增强 * 分类： * 基于接口的动态代理 * 基于子类的动态代理 * 基于接口的动态代理： * 涉及的类：Proxy * 提供者：JDK官方 * 如何创建代理对象： * 使用Proxy类中的newProxyInstance方法 * 创建代理对象的要求： * 被代理类最少实现一个接口，如果没有则不能使用 * newProxyInstance方法的参数： * ClassLoader：类加载器 * 它是用于加载代理对象字节码的。和被代理对象使用相同的类加载器。固定写法。 * Class[]：字节码数组 * 它是用于让代理对象和被代理对象有相同方法。固定写法。 * InvocationHandler：用于提供增强的代码 * 它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。 * 此接口的实现类都是谁用谁写。 */ IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(), producer.getClass().getInterfaces(), new InvocationHandler() &#123; /** * 作用：执行被代理对象的任何接口方法都会经过该方法 * 方法参数的含义 * @param proxy 代理对象的引用 * @param method 当前执行的方法 * @param args 当前执行方法所需的参数 * @return 和被代理对象方法有相同的返回值 * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //提供增强的代码 Object returnValue = null; //1.获取方法执行的参数 Float money = (Float)args[0]; //2.判断当前方法是不是销售 if(\"saleProduct\".equals(method.getName())) &#123; returnValue = method.invoke(producer, money*0.8f); &#125; return returnValue; &#125; &#125;); proxyProducer.saleProduct(10000f); &#125;&#125; 基于子类的动态代理被代理的非最终类123456789101112131415161718public class Producer &#123; /** * 销售 * @param money */ public void saleProduct(float money)&#123; System.out.println(\"销售产品，并拿到钱：\"+money); &#125; /** * 售后 * @param money */ public void afterService(float money)&#123; System.out.println(\"提供售后服务，并拿到钱：\"+money); &#125;&#125; 测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Client &#123; public static void main(String[] args) &#123; final Producer producer = new Producer(); /** * 动态代理： * 特点：字节码随用随创建，随用随加载 * 作用：不修改源码的基础上对方法增强 * 分类： * 基于接口的动态代理 * 基于子类的动态代理 * 基于子类的动态代理： * 涉及的类：Enhancer * 提供者：第三方cglib库 * 如何创建代理对象： * 使用Enhancer类中的create方法 * 创建代理对象的要求： * 被代理类不能是最终类 * create方法的参数： * Class：字节码 * 它是用于指定被代理对象的字节码。 * * Callback：用于提供增强的代码 * 它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。 * 此接口的实现类都是谁用谁写。 * 我们一般写的都是该接口的子接口实现类：MethodInterceptor */ Producer cglibProducer = (Producer)Enhancer.create(producer.getClass(), new MethodInterceptor() &#123; /** * 执行北地阿里对象的任何方法都会经过该方法 * @param proxy * @param method * @param args * 以上三个参数和基于接口的动态代理中invoke方法的参数是一样的 * @param methodProxy ：当前执行方法的代理对象 * @return * @throws Throwable */ @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; //提供增强的代码 Object returnValue = null; //1.获取方法执行的参数 Float money = (Float)args[0]; //2.判断当前方法是不是销售 if(\"saleProduct\".equals(method.getName())) &#123; returnValue = method.invoke(producer, money*0.8f); &#125; return returnValue; &#125; &#125;); cglibProducer.saleProduct(12000f); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"Spring入门3","slug":"Spring入门3","date":"2019-08-14T09:22:13.000Z","updated":"2020-06-04T00:57:09.302Z","comments":true,"path":"2019/08/14/Spring入门3/","link":"","permalink":"https://wang-qp.github.io/2019/08/14/Spring入门3/","excerpt":"","text":"Spring(IOC)使用注解 配置类123456789101112131415161718192021222324252627282930313233343536/** * 该类是一个配置类，它的作用和bean.xml是一样的 * spring中的新注解 * Configuration * 作用：指定当前类是一个配置类 * 细节：当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写。 * ComponentScan * 作用：用于通过注解指定spring在创建容器时要扫描的包 * 属性： * value：它和basePackages的作用是一样的，都是用于指定创建容器时要扫描的包。 * 我们使用此注解就等同于在xml中配置了: * &lt;context:component-scan base-package=\"com.itheima\"&gt;&lt;/context:component-scan&gt; * Bean * 作用：用于把当前方法的返回值作为bean对象存入spring的ioc容器中 * 属性: * name:用于指定bean的id。当不写时，默认值是当前方法的名称 * 细节： * 当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象。 * 查找的方式和Autowired注解的作用是一样的 * Import * 作用：用于导入其他的配置类 * 属性： * value：用于指定其他配置类的字节码。 * 当我们使用Import的注解之后，有Import注解的类就父配置类，而导入的都是子配置类 * PropertySource * 作用：用于指定properties文件的位置 * 属性： * value：指定文件的名称和路径。 * 关键字：classpath，表示类路径下 *///@Configuration@ComponentScan(\"com.itheima\")@Import(JdbcConfig.class)@PropertySource(\"classpath:jdbcConfig.properties\")public class SpringConfiguration &#123;&#125; 子配置类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 和spring连接数据库相关的配置类 */public class JdbcConfig &#123; @Value(\"$&#123;jdbc.driver&#125;\") private String driver; @Value(\"$&#123;jdbc.url&#125;\") private String url; @Value(\"$&#123;jdbc.username&#125;\") private String username; @Value(\"$&#123;jdbc.password&#125;\") private String password; /** * 用于创建一个QueryRunner对象 * @param dataSource * @return */ @Bean(name=\"runner\") @Scope(\"prototype\") public QueryRunner createQueryRunner(@Qualifier(\"ds2\") DataSource dataSource)&#123; return new QueryRunner(dataSource); &#125; /** * 创建数据源对象 * @return */ @Bean(name=\"ds2\") public DataSource createDataSource()&#123; try &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setDriverClass(driver); ds.setJdbcUrl(url); ds.setUser(username); ds.setPassword(password); return ds; &#125;catch (Exception e)&#123; throw new RuntimeException(e); &#125; &#125; @Bean(name=\"ds1\") public DataSource createDataSource1()&#123; try &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setDriverClass(driver); ds.setJdbcUrl(\"jdbc:mysql://localhost:3306/java\"); ds.setUser(username); ds.setPassword(password); return ds; &#125;catch (Exception e)&#123; throw new RuntimeException(e); &#125; &#125;&#125; 持久层123456789101112131415161718/** * 账户的持久层实现类 */@Repository(\"accountDao\")public class AccountDaoImpl implements IAccountDao &#123; @Autowired private QueryRunner runner; @Override public List&lt;Account&gt; findAllAccount() &#123; try&#123; return runner.query(\"select * from account\",new BeanListHandler&lt;Account&gt;(Account.class)); &#125;catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 测试类(spring使用junit)1234567891011121314151617181920212223242526272829/** * 使用Junit单元测试：测试我们的配置 * Spring整合junit的配置 * 1、导入spring整合junit的jar(坐标) * 2、使用Junit提供的一个注解把原有的main方法替换了，替换成spring提供的 * @Runwith * 3、告知spring的运行器，spring和ioc创建是基于xml还是注解的，并且说明位置 * @ContextConfiguration * locations：指定xml文件的位置，加上classpath关键字，表示在类路径下 * classes：指定注解类所在地位置 * * 当我们使用spring 5.x版本的时候，要求junit的jar必须是4.12及以上 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfiguration.class)public class AccountServiceTest &#123; @Autowired private IAccountService as = null; @Test public void testFindAll() &#123; //3.执行方法 List&lt;Account&gt; accounts = as.findAllAccount(); for(Account account : accounts)&#123; System.out.println(account); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"Spring入门2","slug":"Spring入门2","date":"2019-08-12T14:18:29.000Z","updated":"2020-06-04T00:57:09.302Z","comments":true,"path":"2019/08/12/Spring入门2/","link":"","permalink":"https://wang-qp.github.io/2019/08/12/Spring入门2/","excerpt":"","text":"Spring(IOC)使用 注解+xml 配置文件12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--告知spring在创建容器时要扫描的包，配置所需要的标签不是在beans的约束中，而是一个名称为 context名称空间和约束中--&gt; &lt;context:component-scan base-package=\"com.itheima\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; service1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * 账户的业务层实现类 * * 曾经XML的配置： * &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\" * scope=\"\" init-method=\"\" destroy-method=\"\"&gt; * &lt;property name=\"\" value=\"\" | ref=\"\"&gt;&lt;/property&gt; * &lt;/bean&gt; * * 用于创建对象的 * 他们的作用就和在XML配置文件中编写一个&lt;bean&gt;标签实现的功能是一样的 * Component: * 作用：用于把当前类对象存入spring容器中 * 属性： * value：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。 * Controller：一般用在表现层 * Service：一般用在业务层 * Repository：一般用在持久层 * 以上三个注解他们的作用和属性与Component是一模一样。 * 他们三个是spring框架为我们提供明确的三层使用的注解，使我们的三层对象更加清晰 * * * 用于注入数据的 * 他们的作用就和在xml配置文件中的bean标签中写一个&lt;property&gt;标签的作用是一样的 * Autowired: * 作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功 * 如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错。 * 如果Ioc容器中有多个类型匹配时： * 出现位置： * 可以是变量上，也可以是方法上 * 细节： * 在使用注解注入时，set方法就不是必须的了。 * Qualifier: * 作用：在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用。但是在给方法参数注入时可以（稍后我们讲） * 属性： * value：用于指定注入bean的id。 * Resource * 作用：直接按照bean的id注入。它可以独立使用 * 属性： * name：用于指定bean的id。 * 以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。 * 另外，集合类型的注入只能通过XML来实现。 * * Value * 作用：用于注入基本类型和String类型的数据 * 属性： * value：用于指定数据的值。它可以使用spring中SpEL(也就是spring的el表达式） * SpEL的写法：$&#123;表达式&#125; * * 用于改变作用范围的 * 他们的作用就和在bean标签中使用scope属性实现的功能是一样的 * Scope * 作用：用于指定bean的作用范围 * 属性： * value：指定范围的取值。常用取值：singleton prototype * * 和生命周期相关 了解 * 他们的作用就和在bean标签中使用init-method和destroy-methode的作用是一样的 * PreDestroy * 作用：用于指定销毁方法 * PostConstruct * 作用：用于指定初始化方法 */@Service(\"accountService\")//@Scope(\"prototype\")public class AccountServiceImpl implements IAccountService &#123;// @Autowired// @Qualifier(\"accountDao1\") @Resource(name = \"accountDao2\") private IAccountDao accountDao = null; @PostConstruct public void init()&#123; System.out.println(\"初始化方法执行了\"); &#125; @PreDestroy public void destroy()&#123; System.out.println(\"销毁方法执行了\"); &#125; public void saveAccount()&#123; accountDao.saveAccount(); &#125;&#125; 测试类1234567891011121314151617181920public class Client &#123; /** * @param args */ public static void main(String[] args) &#123; //1.获取核心容器对象// ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取Bean对象 IAccountService as = (IAccountService)ac.getBean(\"accountService\");// IAccountService as2 = (IAccountService)ac.getBean(\"accountService\");// System.out.println(as);// IAccountDao adao = ac.getBean(\"accountDao\",IAccountDao.class);// System.out.println(adao);// System.out.println(as == as2); as.saveAccount(); ac.close(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"Spring入门1","slug":"Spring入门1","date":"2019-08-09T12:38:46.000Z","updated":"2020-06-04T00:57:09.301Z","comments":true,"path":"2019/08/09/Spring入门1/","link":"","permalink":"https://wang-qp.github.io/2019/08/09/Spring入门1/","excerpt":"","text":"Spring(IOC)使用xml方式 创建bean123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--把对象的创建交给spring来管理--&gt; &lt;!--spring对bean的管理细节 1.创建bean的三种方式 2.bean对象的作用范围 3.bean对象的生命周期 --&gt; &lt;!--创建Bean的三种方式 --&gt; &lt;!-- 第一种方式：使用默认构造函数创建。 在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时。 采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建。 &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt; --&gt; &lt;!-- 第二种方式： 使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器） &lt;bean id=\"instanceFactory\" class=\"com.itheima.factory.InstanceFactory\"&gt;&lt;/bean&gt; &lt;bean id=\"accountService\" factory-bean=\"instanceFactory\" factory-method=\"getAccountService\"&gt;&lt;/bean&gt; --&gt; &lt;!-- 第三种方式：使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器) &lt;bean id=\"accountService\" class=\"com.itheima.factory.StaticFactory\" factory-method=\"getAccountService\"&gt;&lt;/bean&gt; --&gt; &lt;!-- bean的作用范围调整 bean标签的scope属性： 作用：用于指定bean的作用范围 取值： 常用的就是单例的和多例的 singleton：单例的（默认值） prototype：多例的 request：作用于web应用的请求范围 session：作用于web应用的会话范围 global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\" scope=\"prototype\"&gt;&lt;/bean&gt; --&gt; &lt;!-- bean对象的生命周期 单例对象 出生：当容器创建时对象出生 活着：只要容器还在，对象一直活着 死亡：容器销毁，对象消亡 总结：单例对象的生命周期和容器相同 多例对象 出生：当我们使用对象时spring框架为我们创建 活着：对象只要是在使用过程中就一直活着。 死亡：当对象长时间不用，且没有别的对象引用时，由Java的垃圾回收器回收 --&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\" scope=\"prototype\" init-method=\"init\" destroy-method=\"destroy\"&gt;&lt;/bean&gt;&lt;/beans&gt; 依赖注入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- spring中的依赖注入 依赖注入： Dependency Injection IOC的作用： 降低程序间的耦合（依赖关系） 依赖关系的管理： 以后都交给spring来维护 在当前类需要用到其他类的对象，由spring为我们提供，我们只需要在配置文件中说明 依赖关系的维护： 就称之为依赖注入。 依赖注入： 能注入的数据：有三类 基本类型和String 其他bean类型（在配置文件中或者注解配置过的bean） 复杂类型/集合类型 注入的方式：有三种 第一种：使用构造函数提供 第二种：使用set方法提供 第三种：使用注解提供（明天的内容） --&gt; &lt;!--构造函数注入： 使用的标签:constructor-arg 标签出现的位置：bean标签的内部 标签中的属性 type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型 index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始 name：用于指定给构造函数中指定名称的参数赋值 常用的 =============以上三个用于指定给构造函数中哪个参数赋值=============================== value：用于提供基本类型和String类型的数据 ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象 优势： 在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。 弊端： 改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。 --&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"&gt; &lt;constructor-arg name=\"name\" value=\"泰斯特\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"age\" value=\"18\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"birthday\" ref=\"now\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 配置一个日期对象 --&gt; &lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt; &lt;!-- set方法注入 更常用的方式 涉及的标签：property 出现的位置：bean标签的内部 标签的属性 name：用于指定注入时所调用的set方法名称 value：用于提供基本类型和String类型的数据 ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象 优势： 创建对象时没有明确的限制，可以直接使用默认构造函数 弊端： 如果有某个成员必须有值，则获取对象是有可能set方法没有执行。 --&gt; &lt;bean id=\"accountService2\" class=\"com.itheima.service.impl.AccountServiceImpl2\"&gt; &lt;property name=\"name\" value=\"TEST\" &gt;&lt;/property&gt; &lt;property name=\"age\" value=\"21\"&gt;&lt;/property&gt; &lt;property name=\"birthday\" ref=\"now\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 复杂类型的注入/集合类型的注入 用于给List结构集合注入的标签： list array set 用于个Map结构集合注入的标签: map props 结构相同，标签可以互换 --&gt; &lt;bean id=\"accountService3\" class=\"com.itheima.service.impl.AccountServiceImpl3\"&gt; &lt;property name=\"myStrs\"&gt; &lt;set&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"myList\"&gt; &lt;array&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=\"mySet\"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"myMap\"&gt; &lt;props&gt; &lt;prop key=\"testC\"&gt;ccc&lt;/prop&gt; &lt;prop key=\"testD\"&gt;ddd&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name=\"myProps\"&gt; &lt;map&gt; &lt;entry key=\"testA\" value=\"aaa\"&gt;&lt;/entry&gt; &lt;entry key=\"testB\"&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试代码12345678910111213public class Client &#123; public static void main(String[] args) &#123; //1.获取核心容器对象// ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.根据id获取Bean对象 IAccountService as = (IAccountService)ac.getBean(\"accountService\"); as.saveAccount(); //手动关闭容器 ac.close(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"mybatis入门2","slug":"mybatis入门2","date":"2019-08-06T14:39:05.000Z","updated":"2020-06-04T00:57:09.307Z","comments":true,"path":"2019/08/06/mybatis入门2/","link":"","permalink":"https://wang-qp.github.io/2019/08/06/mybatis入门2/","excerpt":"","text":"mybatis 注解方式 mybatis 注解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll(); /** * 保存用户 * @param user */ @Insert(&quot;insert into user(username,address,sex,birthday)values(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;)&quot;) void saveUser(User user); /** * 更新用户 * @param user */ @Update(&quot;update user set username=#&#123;username&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;&quot;) void updateUser(User user); /** * 删除用户 * @param userId */ @Delete(&quot;delete from user where id=#&#123;id&#125; &quot;) void deleteUser(Integer userId); /** * 根据id查询用户 * @param userId * @return */ @Select(&quot;select * from user where id=#&#123;id&#125; &quot;) User findById(Integer userId); /** * 根据用户名称模糊查询 * @param username * @return */// @Select(&quot;select * from user where username like #&#123;username&#125; &quot;) @Select(&quot;select * from user where username like &apos;%$&#123;value&#125;%&apos; &quot;) List&lt;User&gt; findUserByName(String username); /** * 查询总用户数量 * @return */ @Select(&quot;select count(*) from user &quot;) int findTotalUser();&#125; 一对多注解IUserDao1234567891011121314151617181920212223242526272829303132333435363738@CacheNamespace(blocking = true)public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select(\"select * from user\") @Results(id=\"userMap\",value=&#123; @Result(id=true,column = \"id\",property = \"userId\"), @Result(column = \"username\",property = \"userName\"), @Result(column = \"address\",property = \"userAddress\"), @Result(column = \"sex\",property = \"userSex\"), @Result(column = \"birthday\",property = \"userBirthday\"), @Result(property = \"accounts\",column = \"id\", many = @Many(select = \"com.itheima.dao.IAccountDao.findAccountByUid\", fetchType = FetchType.LAZY)) &#125;) List&lt;User&gt; findAll(); /** * 根据id查询用户 * @param userId * @return */ @Select(\"select * from user where id=#&#123;id&#125; \") @ResultMap(\"userMap\") User findById(Integer userId); /** * 根据用户名称模糊查询 * @param username * @return */ @Select(\"select * from user where username like #&#123;username&#125; \") @ResultMap(\"userMap\") List&lt;User&gt; findUserByName(String username);&#125; IAccountDao1234567891011121314151617181920212223public interface IAccountDao &#123; /** * 查询所有账户，并且获取每个账户所属的用户信息 * @return */ @Select(\"select * from account\") @Results(id=\"accountMap\",value = &#123; @Result(id=true,column = \"id\",property = \"id\"), @Result(column = \"uid\",property = \"uid\"), @Result(column = \"money\",property = \"money\"), @Result(property = \"user\",column = \"uid\",one=@One(select=\"com.itheima.dao.IUserDao.findById\",fetchType= FetchType.EAGER)) &#125;) List&lt;Account&gt; findAll(); /** * 根据用户id查询账户信息 * @param userId * @return */ @Select(\"select * from account where uid = #&#123;userId&#125;\") List&lt;Account&gt; findAccountByUid(Integer userId);&#125; 测试类12345678910111213141516171819202122232425262728293031323334353637383940414243public class AnnotationCRUDTest &#123; private InputStream in; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Before public void init()throws Exception&#123; in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); factory = new SqlSessionFactoryBuilder().build(in); session = factory.openSession(); userDao = session.getMapper(IUserDao.class); &#125; @After public void destroy()throws Exception&#123; session.commit(); session.close(); in.close(); &#125; @Test public void testFindAll()&#123; List&lt;User&gt; users = userDao.findAll();// for(User user : users)&#123;// System.out.println(\"---每个用户的信息----\");// System.out.println(user);// System.out.println(user.getAccounts());// &#125; &#125; @Test public void testFindOne()&#123; User user = userDao.findById(57); System.out.println(user); &#125; @Test public void testFindByName()&#123; List&lt;User&gt; users = userDao.findUserByName(\"%mybatis%\"); for(User user : users)&#123; System.out.println(user); &#125; &#125;&#125; mybatis 缓存* 像大多数的持久化框架一样，Mybatis 也提供了缓存策略，通过缓存策略来减少数据库的查询次数，从而提高性能。 Mybatis 中缓存分为一级缓存，二级缓存。 * 一级缓存是 SqlSession 级别的缓存，只要 SqlSession 没有 flush 或 close，它就存在。 * 一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()等 * 二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句， 多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。测试类1234567891011121314151617181920212223242526272829303132public class SecondLevelCatchTest &#123; private InputStream in; private SqlSessionFactory factory; @Before public void init()throws Exception&#123; in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); factory = new SqlSessionFactoryBuilder().build(in); &#125; @After public void destroy()throws Exception&#123; in.close(); &#125; @Test public void testFindOne()&#123; SqlSession session = factory.openSession(); IUserDao userDao = session.getMapper(IUserDao.class); User user = userDao.findById(57); System.out.println(user); session.close();//释放一级缓存 SqlSession session1 = factory.openSession();//再次打开session IUserDao userDao1 = session1.getMapper(IUserDao.class); User user1 = userDao1.findById(57); System.out.println(user1); session1.close(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"mybatis入门1","slug":"mybatis入门1","date":"2019-08-06T13:55:42.000Z","updated":"2020-06-04T00:57:09.307Z","comments":true,"path":"2019/08/06/mybatis入门1/","link":"","permalink":"https://wang-qp.github.io/2019/08/06/mybatis入门1/","excerpt":"","text":"mybatis框架概述:是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql 语句本身， 而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。 mybatis 通过 xml 或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并 返回。 采用 ORM 思想解决了实体和数据库映射的问题，对 jdbc 进行了封装，屏蔽了 jdbc api 底层访问细节，使我 们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。 为了我们能够更好掌握框架运行的内部过程，并且有更好的体验，下面我们将从自定义 Mybatis 框架开始来 学习框架。此时我们将会体验框架从无到有的过程体验，也能够很好的综合前面阶段所学的基础。SqlMapConfig.xml 配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;properties resource=\"jdbcConfig.properties\"&gt;&lt;/properties&gt; &lt;!--配置参数--&gt; &lt;settings&gt; &lt;!--开启Mybatis支持延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"&gt;&lt;/setting&gt; &lt;/settings&gt; &lt;!--使用typeAliases配置别名，它只能配置domain中类的别名 --&gt; &lt;typeAliases&gt; &lt;!--typeAlias用于配置别名。type属性指定的是实体类全限定类名。alias属性指定别名，当指定了别名就再区分大小写 &lt;typeAlias type=\"com.itheima.domain.User\" alias=\"user\"&gt;&lt;/typeAlias&gt;--&gt; &lt;!-- 用于指定要配置别名的包，当指定之后，该包下的实体类都会注册别名，并且类名就是别名，不再区分大小写--&gt; &lt;package name=\"cn.wang.domain\"&gt;&lt;/package&gt; &lt;/typeAliases&gt; &lt;!--配置文件 --&gt; &lt;environments default=\"mysql\"&gt; &lt;!--配置mysql的环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!-- 配置事务 --&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!-- 配置连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 配置映射文件路径--&gt; &lt;mappers&gt;&lt;!-- &lt;mapper resource=\"cn/wang/dao/UserDao.xml\"&gt;&lt;/mapper&gt;--&gt; &lt;!-- package标签是用于指定dao接口所在的包,当指定了之后就不需要在写mapper以及resource或者class了 --&gt; &lt;package name=\"cn.wang.dao\"&gt;&lt;/package&gt; &lt;/mappers&gt;&lt;/configuration&gt; 持久层接口的映射文件 UserDao.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"cn.wang.dao.UserDao\"&gt; &lt;sql id=\"default\"&gt; select *from user &lt;/sql&gt; &lt;select id=\"findAll\" resultType=\"cn.wang.domain.User\"&gt; &lt;include refid=\"default\"&gt;&lt;/include&gt; &lt;/select&gt; &lt;insert id=\"saveUser\" parameterType=\"cn.wang.domain.User\"&gt; &lt;selectKey keyProperty=\"id\" keyColumn=\"id\" resultType=\"int\" order=\"AFTER\"&gt; select last_insert_id(); &lt;/selectKey&gt; insert into user(username,address,sex,birthday) value(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;); &lt;/insert&gt; &lt;update id=\"updateUser\" parameterType=\"cn.wang.domain.User\"&gt; update user set address=#&#123;address&#125; where username=#&#123;username&#125;; &lt;/update&gt; &lt;delete id=\"deleteUser\" parameterType=\"java.lang.Integer\"&gt; delete from user where id=#&#123;uid&#125;; &lt;/delete&gt; &lt;select id=\"findOne\" parameterType=\"java.lang.Integer\" resultType=\"cn.wang.domain.User\"&gt; select * from user where id=#&#123;uid&#125;; &lt;/select&gt; &lt;select id=\"findByCondition\" resultType=\"cn.wang.domain.User\" parameterType=\"cn.wang.domain.User\"&gt; &lt;!--select * from user where 1=1 &lt;if test=\"username != null\"&gt; and username = #&#123;username&#125; &lt;/if&gt;--&gt; select * from user &lt;where&gt; &lt;if test=\"username != null\"&gt; and username = #&#123;username&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id=\"findUserInIds\" resultType=\"cn.wang.domain.User\" parameterType=\"cn.wang.domain.QueryVo\"&gt; &lt;include refid=\"default\"&gt;&lt;/include&gt; &lt;where&gt; &lt;if test=\"ids !=null and ids.size()&gt;0\"&gt; &lt;foreach collection=\"ids\" open=\"and id in(\" close=\")\" item=\"id\" separator=\",\"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 一对多 xml配置1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.itheima.dao.IUserDao\"&gt; &lt;!-- 定义User的resultMap--&gt; &lt;resultMap id=\"userAccountMap\" type=\"user\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"address\" column=\"address\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;!-- 配置user对象中accounts集合的映射 --&gt; &lt;collection property=\"accounts\" ofType=\"account\"&gt; &lt;id column=\"aid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"uid\" property=\"uid\"&gt;&lt;/result&gt; &lt;result column=\"money\" property=\"money\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 查询所有 --&gt; &lt;select id=\"findAll\" resultMap=\"userAccountMap\"&gt; select * from user u left outer join account a on u.id = a.uid &lt;/select&gt; &lt;!-- 根据id查询用户 --&gt; &lt;select id=\"findById\" parameterType=\"INT\" resultType=\"user\"&gt; select * from user where id = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 多对多 xml配置12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.itheima.dao.IUserDao\"&gt; &lt;!-- 定义User的resultMap--&gt; &lt;resultMap id=\"userMap\" type=\"user\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"username\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"address\" column=\"address\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"birthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;!-- 配置角色集合的映射 --&gt; &lt;collection property=\"roles\" ofType=\"role\"&gt; &lt;id property=\"roleId\" column=\"rid\"&gt;&lt;/id&gt; &lt;result property=\"roleName\" column=\"role_name\"&gt;&lt;/result&gt; &lt;result property=\"roleDesc\" column=\"role_desc\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 查询所有 --&gt; &lt;select id=\"findAll\" resultMap=\"userMap\"&gt; select u.*,r.id as rid,r.role_name,r.role_desc from user u left outer join user_role ur on u.id = ur.uid left outer join role r on r.id = ur.rid &lt;/select&gt; &lt;!-- 根据id查询用户 --&gt; &lt;select id=\"findById\" parameterType=\"INT\" resultType=\"user\"&gt; select * from user where id = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 编写测试类123456789101112131415161718192021222324252627282930313233343536public class UserTest &#123; private InputStream in; private SqlSession sqlSession; private IUserDao userDao; @Before//用于在测试方法执行之前执行 public void init()throws Exception&#123; //1.读取配置文件，生成字节输入流 in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.获取SqlSessionFactory SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //3.获取SqlSession对象 sqlSession = factory.openSession(true); //4.获取dao的代理对象 userDao = sqlSession.getMapper(IUserDao.class); &#125; @After//用于在测试方法执行之后执行 public void destroy()throws Exception&#123; //提交事务 // sqlSession.commit(); //6.释放资源 sqlSession.close(); in.close(); &#125; /** * 测试查询所有 */ @Test public void testFindAll()&#123; List&lt;User&gt; users = userDao.findAll(); for(User user : users)&#123; System.out.println(\"-----每个用户的信息------\"); System.out.println(user); System.out.println(user.getRoles()); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wang-qp.github.io/tags/框架/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"redis","slug":"redis","date":"2019-07-26T13:11:48.000Z","updated":"2020-06-04T00:57:09.308Z","comments":true,"path":"2019/07/26/redis/","link":"","permalink":"https://wang-qp.github.io/2019/07/26/redis/","excerpt":"","text":"Redis1. 概念： redis是一款高性能的NOSQL系列的非关系型数据库 1.1.什么是NOSQL NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 1.1.1. NOSQL和关系型数据库比较 优点： 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 3）不提供关系型数据库对事务的处理。 1.1.2. 非关系型数据库的优势： 1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 1.1.3. 关系型数据库的优势： 1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 1.1.4. 总结 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库， 让NoSQL数据库对关系型数据库的不足进行弥补。 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 1.2.主流的NOSQL产品 • 键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化 • 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 • 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 • 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 1.3 什么是Redis Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 1) 字符串类型 string 2) 哈希类型 hash 3) 列表类型 list 4) 集合类型 set 5) 有序集合类型 sortedset 1.3.1 redis的应用场景 • 缓存（数据查询、短连接、新闻内容、商品内容等等） • 聊天室的在线好友列表 • 任务队列。（秒杀、抢购、12306等等） • 应用排行榜 • 网站访问统计 • 数据过期处理（可以精确到毫秒 • 分布式集群架构中的session分离 2. 下载安装 1. 官网：https://redis.io 2. 中文网：http://www.redis.net.cn/ 3. 解压直接可以使用： * redis.windows.conf：配置文件 * redis-cli.exe：redis的客户端 * redis-server.exe：redis服务器端 3. 命令操作 1. redis的数据结构： * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 * value的数据结构： 1) 字符串类型 string 2) 哈希类型 hash ： map格式 3) 列表类型 list ： linkedlist格式。支持重复元素 4) 集合类型 set ： 不允许重复元素 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 2. 字符串类型 string 1. 存储： set key value 127.0.0.1:6379&gt; set username zhangsan OK 2. 获取： get key 127.0.0.1:6379&gt; get username &quot;zhangsan&quot; 3. 删除： del key 127.0.0.1:6379&gt; del age (integer) 1 3. 哈希类型 hash 1. 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 2. 获取： * hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot; * hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) &quot;username&quot; 2) &quot;lisi&quot; 3) &quot;password&quot; 4) &quot;123&quot; 3. 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 1 4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 1. 添加： 1. lpush key value: 将元素加入列表左表 2. rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： * lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot; 3. 删除： * lpop key： 删除列表最左边的元素，并将元素返回 * rpop key： 删除列表最右边的元素，并将元素返回 5. 集合类型 set ： 不允许重复元素 1. 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 2. 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 3. 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 1 6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 1. 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 2. 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) &quot;zhangsan&quot; 2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot; 6) &quot;500&quot; 3. 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 7. 通用命令 1. keys * : 查询所有的键 2. type key ： 获取键对应的value的类型 3. del key：删除指定的key value 4. 持久化 1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 2. redis持久化机制： 1. RDB：默认方式，不需要进行配置，默认就使用这种机制 * 在一定的间隔时间中，检测key的变化情况，然后持久化数据 1. 编辑redis.windwos.conf文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 10000 2. 重新启动redis服务器，并指定配置文件名称 D:\\JavaWeb2018\\day23_redis\\资料\\redis\\windows-64\\redis-2.8.9&gt;redis-server.exe redis.windows.conf 2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 1. 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） # appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化 5. Java客户端 Jedis * Jedis: 一款java操作redis数据库的工具. * 使用步骤： 1. 下载jedis的jar包 2. 使用 //1. 获取连接 Jedis jedis = new Jedis(&quot;localhost&quot;,6379); //2. 操作 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //3. 关闭连接 jedis.close(); * Jedis操作各种redis中的数据结构 1) 字符串类型 string set get //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 //存储 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //获取 String username = jedis.get(&quot;username&quot;); System.out.println(username); //可以使用setex()方法存储可以指定过期时间的 key value jedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对 //3. 关闭连接 jedis.close(); 2) 哈希类型 hash ： map格式 hset hget hgetAll //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // 存储hash jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;); jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;); jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;); // 获取hash String name = jedis.hget(&quot;user&quot;, &quot;name&quot;); System.out.println(name); // 获取hash的所有map中的数据 Map&lt;String, String&gt; user = jedis.hgetAll(&quot;user&quot;); // keyset Set&lt;String&gt; keySet = user.keySet(); for (String key : keySet) { //获取value String value = user.get(key); System.out.println(key + &quot;:&quot; + value); } //3. 关闭连接 jedis.close(); 3) 列表类型 list ： linkedlist格式。支持重复元素 lpush / rpush lpop / rpop lrange start end : 范围获取 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // list 存储 jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存 jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存 // list 范围获取 List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist); // list 弹出 String element1 = jedis.lpop(&quot;mylist&quot;);//c System.out.println(element1); String element2 = jedis.rpop(&quot;mylist&quot;);//c System.out.println(element2); // list 范围获取 List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist2); //3. 关闭连接 jedis.close(); 4) 集合类型 set ： 不允许重复元素 sadd smembers:获取所有元素 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // set 存储 jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c++&quot;); // set 获取 Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;); System.out.println(myset); //3. 关闭连接 jedis.close(); 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 zadd zrange //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // sortedset 存储 jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;); jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;); jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;); // sortedset 获取 Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1); System.out.println(mysortedset); //3. 关闭连接 jedis.close(); * jedis连接池： JedisPool * 使用： 1. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 //0.创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379); //2.获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set(&quot;hehe&quot;,&quot;heihei&quot;); //4. 关闭 归还到连接池中 jedis.close(); * 连接池工具类 public class JedisPoolUtils { private static JedisPool jedisPool; static{ //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); //创建Properties对象 Properties pro = new Properties(); //关联文件 try { pro.load(is); } catch (IOException e) { e.printStackTrace(); } //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;))); config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;))); } /** * 获取连接方法 */ public static Jedis getJedis(){ return jedisPool.getResource(); } }案例：案例需求： 1. 提供index.html页面，页面中有一个省份 下拉列表 2. 当 页面加载完成后 发送ajax请求，加载所有省份 * 注意：使用redis缓存一些不经常发生变化的数据。 * 数据库的数据一旦发生改变，则需要更新缓存。 * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入 * 在service对应的增删改方法中，将redis数据删除。 * 访问jedis1234567891011121314151617181920212223242526272829public class ProvinceServiceImpl implements ProvinceService &#123; private ProvinceDao dao = new ProvinceDaoImpl(); @Override public List&lt;Province&gt; findAll() &#123; return dao.findAll(); &#125; @Override public String findAllJson() &#123; Jedis jedis = JedisPoolUtils.getJedis(); String province_json = jedis.get(\"province\"); if (province_json == null || province_json.length() == 0) &#123; System.out.println(\"redis中没有数据，访问数据库\"); List&lt;Province&gt; list = dao.findAll(); ObjectMapper mapper = new ObjectMapper(); try &#123; province_json = mapper.writeValueAsString(list); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; jedis.set(\"province\",province_json); jedis.close(); &#125; else &#123; System.out.println(\"redis中有数据，访问缓存\"); &#125; return province_json; &#125;&#125;","categories":[{"name":"SQL","slug":"SQL","permalink":"https://wang-qp.github.io/categories/SQL/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://wang-qp.github.io/tags/redis/"}],"keywords":[{"name":"SQL","slug":"SQL","permalink":"https://wang-qp.github.io/categories/SQL/"}]},{"title":"JQuery","slug":"JQuery","date":"2019-07-25T12:47:52.000Z","updated":"2020-06-04T00:57:09.294Z","comments":true,"path":"2019/07/25/JQuery/","link":"","permalink":"https://wang-qp.github.io/2019/07/25/JQuery/","excerpt":"","text":"JQuery 基础：1. 概念： 一个JavaScript框架。简化JS开发 * jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨 是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优 化HTML文档操作、事件处理、动画设计和Ajax交互。 * JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已 2. 快速入门 1. 步骤： 1. 下载JQuery * 目前jQuery有三个大版本： 1.x：兼容ie678,使用最为广泛的，官方只做BUG维护， 功能不再新增。因此一般项目来说，使用1.x版本就可以了， 最终版本：1.12.4 (2016年5月20日) 2.x：不兼容ie678，很少有人使用，官方只做BUG维护， 功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x， 最终版本：2.2.4 (2016年5月20日) 3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求， 一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。 目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日） * jquery-xxx.js 与 jquery-xxx.min.js区别： 1. jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些 2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快 2. 导入JQuery的js文件：导入min.js文件 3. 使用 var div1 = $(&quot;#div1&quot;); alert(div1.html()); 3. JQuery对象和JS对象区别与转换 1. JQuery对象在操作时，更加方便。 2. JQuery对象和js对象方法不通用的. 3. 两者相互转换 * jq -- &gt; js : jq对象[索引] 或者 jq对象.get(索引) * js -- &gt; jq : $(js对象) 4. 选择器：筛选具有相似特征的元素(标签) 1. 基本操作学习： 1. 事件绑定 //1.获取b1按钮 $(&quot;#b1&quot;).click(function(){ alert(&quot;abc&quot;); }); 2. 入口函数 $(function () { }); window.onload 和 $(function) 区别 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉 * $(function)可以定义多次的。 3. 样式控制：css方法 // $(&quot;#div1&quot;).css(&quot;background-color&quot;,&quot;red&quot;); $(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); 2. 分类 1. 基本选择器 1. 标签选择器（元素选择器） * 语法： $(&quot;html标签名&quot;) 获得所有匹配标签名称的元素 2. id选择器 * 语法： $(&quot;#id的属性值&quot;) 获得与指定id属性值匹配的元素 3. 类选择器 * 语法： $(&quot;.class的属性值&quot;) 获得与指定的class属性值匹配的元素 4. 并集选择器： * 语法： $(&quot;选择器1,选择器2....&quot;) 获取多个选择器选中的所有元素 2. 层级选择器 1. 后代选择器 * 语法： $(&quot;A B &quot;) 选择A元素内部的所有B元素 2. 子选择器 * 语法： $(&quot;A &gt; B&quot;) 选择A元素内部的所有B子元素 3. 属性选择器 1. 属性名称选择器 * 语法： $(&quot;A[属性名]&quot;) 包含指定属性的选择器 2. 属性选择器 * 语法： $(&quot;A[属性名=&apos;值&apos;]&quot;) 包含指定属性等于指定值的选择器 3. 复合属性选择器 * 语法： $(&quot;A[属性名=&apos;值&apos;][]...&quot;) 包含多个属性条件的选择器 4. 过滤选择器 1. 首元素选择器 * 语法： :first 获得选择的元素中的第一个元素 2. 尾元素选择器 * 语法： :last 获得选择的元素中的最后一个元素 3. 非元素选择器 * 语法： :not(selector) 不包括指定内容的元素 4. 偶数选择器 * 语法： :even 偶数，从 0 开始计数 5. 奇数选择器 * 语法： :odd 奇数，从 0 开始计数 6. 等于索引选择器 * 语法： :eq(index) 指定索引元素 7. 大于索引选择器 * 语法： :gt(index) 大于指定索引元素 8. 小于索引选择器 * 语法： :lt(index) 小于指定索引元素 9. 标题选择器 * 语法： :header 获得标题（h1~h6）元素，固定写法 5. 表单过滤选择器 1. 可用元素选择器 * 语法： :enabled 获得可用元素 2. 不可用元素选择器 * 语法： :disabled 获得不可用元素 3. 选中选择器 * 语法： :checked 获得单选/复选框选中的元素 4. 选中选择器 * 语法： :selected 获得下拉框选中的元素 5. DOM操作 1. 内容操作 1. html(): 获取/设置元素的标签体内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; &lt;font&gt;内容&lt;/font&gt; 2. text(): 获取/设置元素的标签体纯文本内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容 3. val()： 获取/设置元素的value属性值 2. 属性操作 1. 通用属性操作 1. attr(): 获取/设置元素的属性 2. removeAttr():删除属性 3. prop():获取/设置元素的属性 4. removeProp():删除属性 * attr和prop区别？ 1. 如果操作的是元素的固有属性，则建议使用prop 2. 如果操作的是元素自定义的属性，则建议使用attr 2. 对class属性操作 1. addClass():添加class属性值 2. removeClass():删除class属性值 3. toggleClass():切换class属性 * toggleClass(&quot;one&quot;): * 判断如果元素对象上存在class=&quot;one&quot;，则将属性值one删除掉。 如果元素对象上不存在class=&quot;one&quot;，则添加 4. css(): 3. CRUD操作: 1. append():父元素将子元素追加到末尾 * 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾 2. prepend():父元素将子元素追加到开头 * 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头 3. appendTo(): * 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾 4. prependTo()： * 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头 5. after():添加元素到元素后边 * 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系 6. before():添加元素到元素前边 * 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 7. insertAfter() * 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系 8. insertBefore() * 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 9. remove():移除元素 * 对象.remove():将对象删除掉 10. empty():清空元素的所有后代元素。 * 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点JQuery 高级1. 动画 1. 三种方式显示和隐藏元素 1. 默认显示和隐藏方式 1. show([speed,[easing],[fn]]) 1. 参数： 1. speed：动画的速度。三个预定义的值(&quot;slow&quot;,&quot;normal&quot;, &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000) 2. easing：用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot; * swing：动画执行时效果是 先慢，中间快，最后又慢 * linear：动画执行时速度是匀速的 3. fn：在动画完成时执行的函数，每个元素执行一次。 2. hide([speed,[easing],[fn]]) 3. toggle([speed],[easing],[fn]) 2. 滑动显示和隐藏方式 1. slideDown([speed],[easing],[fn]) 2. slideUp([speed,[easing],[fn]]) 3. slideToggle([speed],[easing],[fn]) 3. 淡入淡出显示和隐藏方式 1. fadeIn([speed],[easing],[fn]) 2. fadeOut([speed],[easing],[fn]) 3. fadeToggle([speed,[easing],[fn]]) 2. 遍历 1. js的遍历方式 * for(初始化值;循环结束条件;步长) 2. jq的遍历方式 1. jq对象.each(callback) 1. 语法： jquery对象.each(function(index,element){}); * index:就是元素在集合中的索引 * element：就是集合中的每一个元素对象 * this：集合中的每一个元素对象 2. 回调函数返回值： * true:如果当前function返回为false，则结束循环(break)。 * false:如果当前function返回为true，则结束本次循环，继续下次循环(continue) 2. $.each(object, [callback]) 3. for..of: jquery 3.0 版本之后提供的方式 for(元素对象 of 容器对象) 3. 事件绑定 1. jquery标准的绑定方式 * jq对象.事件方法(回调函数)； * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。 * 表单对象.submit();//让表单提交 2. on绑定事件/off解除绑定 * jq对象.on(&quot;事件名称&quot;,回调函数) * jq对象.off(&quot;事件名称&quot;) * 如果off方法不传递任何参数，则将组件上的所有事件全部解绑 3. 事件切换：toggle * jq对象.toggle(fn1,fn2...) * 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2..... * 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。 &lt;script src=&quot;../js/jquery-migrate-1.0.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; 4. 案例 1. 广告显示和隐藏 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;广告的自动显示与隐藏&lt;/title&gt; &lt;style&gt; #content{width:100%;height:500px;background:#999} &lt;/style&gt; &lt;!--引入jquery--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; /* 需求： 1. 当页面加载完，3秒后。自动显示广告 2. 广告显示5秒后，自动消失。 分析： 1. 使用定时器来完成。setTimeout (执行一次定时器) 2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display 3. 使用 show/hide方法来完成广告的显示 */ //入口函数，在页面加载完成之后，定义定时器，调用这两个方法 $(function () { //定义定时器，调用adShow方法 3秒后执行一次 setTimeout(adShow,3000); //定义定时器，调用adHide方法，8秒后执行一次 setTimeout(adHide,8000); }); //显示广告 function adShow() { //获取广告div，调用显示方法 $(&quot;#ad&quot;).show(&quot;slow&quot;); } //隐藏广告 function adHide() { //获取广告div，调用隐藏方法 $(&quot;#ad&quot;).hide(&quot;slow&quot;); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 整体的DIV --&gt; &lt;div&gt; &lt;!-- 广告DIV --&gt; &lt;div id=&quot;ad&quot; style=&quot;display: none;&quot;&gt; &lt;img style=&quot;width:100%&quot; src=&quot;../img/adv.jpg&quot; /&gt; &lt;/div&gt; &lt;!-- 下方正文部分 --&gt; &lt;div id=&quot;content&quot;&gt; 正文部分 &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 2. 抽奖 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jquery案例之抽奖&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script language=&apos;javascript&apos; type=&apos;text/javascript&apos;&gt; /* 分析： 1. 给开始按钮绑定单击事件 1.1 定义循环定时器 1.2 切换小相框的src属性 * 定义数组，存放图片资源路径 * 生成随机数。数组索引 2. 给结束按钮绑定单击事件 1.1 停止定时器 1.2 给大相框设置src属性 */ var imgs = [&quot;../img/man00.jpg&quot;, &quot;../img/man01.jpg&quot;, &quot;../img/man02.jpg&quot;, &quot;../img/man03.jpg&quot;, &quot;../img/man04.jpg&quot;, &quot;../img/man05.jpg&quot;, &quot;../img/man06.jpg&quot;, ]; var startId;//开始定时器的id var index;//随机角标 $(function () { //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); //1. 给开始按钮绑定单击事件 $(&quot;#startID&quot;).click(function () { // 1.1 定义循环定时器 20毫秒执行一次 startId = setInterval(function () { //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,true); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,false); //1.2生成随机角标 0-6 index = Math.floor(Math.random() * 7);//0.000--0.999 --&gt; * 7 --&gt; 0.0-----6.9999 //1.3设置小相框的src属性 $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]); },20); }); //2. 给结束按钮绑定单击事件 $(&quot;#stopID&quot;).click(function () { //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); // 1.1 停止定时器 clearInterval(startId); // 1.2 给大相框设置src属性 $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]).hide(); //显示1秒之后 $(&quot;#img2ID&quot;).show(1000); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 小像框 --&gt; &lt;div style=&quot;border-style:dotted;width:160px;height:100px&quot;&gt; &lt;img id=&quot;img1ID&quot; src=&quot;../img/man00.jpg&quot; style=&quot;width:160px;height:100px&quot;/&gt; &lt;/div&gt; &lt;!-- 大像框 --&gt; &lt;div style=&quot;border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px&quot;&gt; &lt;img id=&quot;img2ID&quot; src=&quot;../img/man00.jpg&quot; width=&quot;800px&quot; height=&quot;500px&quot;/&gt; &lt;/div&gt; &lt;!-- 开始按钮 --&gt; &lt;input id=&quot;startID&quot; type=&quot;button&quot; value=&quot;点击开始&quot; style=&quot;width:150px;height:150px;font-size:22px&quot;&gt; &lt;!-- 停止按钮 --&gt; &lt;input id=&quot;stopID&quot; type=&quot;button&quot; value=&quot;点击停止&quot; style=&quot;width:150px;height:150px;font-size:22px&quot;&gt; &lt;/body&gt; &lt;/html&gt; 5. 插件：增强JQuery的功能 1. 实现方式： 1. $.fn.extend(object) * 增强通过Jquery获取的对象的功能 $(&quot;#id&quot;) 2. $.extend(object) * 增强JQeury对象自身的功能 $/jQuery","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wang-qp.github.io/categories/JavaScript/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://wang-qp.github.io/tags/JQuery/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wang-qp.github.io/categories/JavaScript/"}]},{"title":"Filter&Listener笔记","slug":"Filter-Listener笔记","date":"2019-07-24T13:22:34.000Z","updated":"2020-06-04T00:57:09.293Z","comments":true,"path":"2019/07/24/Filter-Listener笔记/","link":"","permalink":"https://wang-qp.github.io/2019/07/24/Filter-Listener笔记/","excerpt":"","text":"Filter：过滤器1. 概念： * 生活中的过滤器：净水器,空气净化器，土匪、 * web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。 * 过滤器的作用： * 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤... 2. 快速入门： 1. 步骤： 1. 定义一个类，实现接口Filter 2. 复写方法 3. 配置拦截路径 1. web.xml 2. 注解 2. 代码： @WebFilter(&quot;/*&quot;)//访问所有资源之前，都会执行该过滤器 123456789101112131415161718192021public class FilterDemo1 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(\"filterDemo1被执行了....\"); //放行 filterChain.doFilter(servletRequest,servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; 3. 过滤器细节： 1. web.xml配置 &lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 2. 过滤器执行流程 1. 执行过滤器 2. 执行放行后的资源 3. 回来执行过滤器放行代码下边的代码 3. 过滤器生命周期方法 1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 2. doFilter:每一次请求被拦截资源时，会执行。执行多次 3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源 4. 过滤器配置详解 * 拦截路径配置： 1. 具体资源路径： /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 2. 拦截目录： /user/* 访问/user下的所有资源时，过滤器都会被执行 3. 后缀名拦截： *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 4. 拦截所有资源：/* 访问所有资源时，过滤器都会被执行 * 拦截方式配置：资源被访问的方式 * 注解配置： * 设置dispatcherTypes属性 1. REQUEST：默认值。浏览器直接请求资源 2. FORWARD：转发访问资源 3. INCLUDE：包含访问资源 4. ERROR：错误跳转资源 5. ASYNC：异步访问资源 * web.xml配置 * 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可 5. 过滤器链(配置多个过滤器) * 执行顺序：如果有两个过滤器：过滤器1和过滤器2 1. 过滤器1 2. 过滤器2 3. 资源执行 4. 过滤器2 5. 过滤器1 * 过滤器先后顺序问题： 1. 注解配置：按照类名的字符串比较规则比较，值小的先执行 * 如： AFilter 和 BFilter，AFilter就先执行了。 2. web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行 4. 案例： 1. 案例1_登录验证 * 需求： 1. 访问day17_case案例的资源。验证其是否登录 2. 如果登录了，则直接放行。 3. 如果没有登录，则跳转到登录页面，提示&quot;您尚未登录，请先登录&quot;。 123456789101112131415 public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; HttpServletRequest request = (HttpServletRequest) req; String uri = request.getRequestURI(); if (uri.contains(\"/login.jsp\") || uri.contains(\"loginServlet\") || uri.contains(\"/js/\") || uri.contains(\"/css/\") || uri.contains(\"/fonts/\") || uri.contains(\"/checkCodeServlet\")) &#123; chain.doFilter(req, resp); &#125; else &#123; Object user = request.getSession().getAttribute(\"user\"); if (user != null) &#123; chain.doFilter(req, resp); &#125; else &#123; request.setAttribute(\"login_msg\",\"请登录后操作\"); request.getRequestDispatcher(\"/login.jsp\").forward(request,resp); &#125; &#125;&#125; 2. 案例2_敏感词汇过滤 * 需求： 1. 对day17_case案例录入的数据进行敏感词汇过滤 2. 敏感词汇参考《敏感词汇.txt》 3. 如果是敏感词汇，替换为 *** * 分析： 1. 对request对象进行增强。增强获取参数相关方法 2. 放行。传递代理对象 * 增强对象的功能： * 设计模式：一些通用的解决固定问题的方式 1. 装饰模式 2. 代理模式 * 概念： 1. 真实对象：被代理的对象 2. 代理对象： 3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的 * 实现方式： 1. 静态代理：有一个类文件描述代理模式 2. 动态代理：在内存中形成代理类 * 实现步骤： 1. 代理对象和真实对象实现相同的接口 2. 代理对象 = Proxy.newProxyInstance(); 3. 使用代理对象调用方法。 4. 增强方法 * 增强方式： 1. 增强参数列表 2. 增强返回值类型 3. 增强方法体执行逻辑 12345678910111213141516171819202122232425262728293031323334353637383940public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; ServletRequest proxy_req = (ServletRequest) Proxy.newProxyInstance(req.getClass().getClassLoader(), req.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (method.getName() == \"getParameter\") &#123; String value = (String) method.invoke(req,args); if (value != null) &#123; for (String str : list) &#123; if (value.contains(str)) &#123; value = value.replaceAll(str, \"***\"); &#125; &#125; &#125; System.out.println(\"return:\"+value); return value; &#125; return method.invoke(req,args); &#125; &#125;); chain.doFilter(proxy_req, resp);&#125;private List&lt;String&gt; list = new ArrayList&lt;&gt;();public void init(FilterConfig config) throws ServletException &#123; try &#123; ServletContext servletContext = config.getServletContext(); String realPath = servletContext.getRealPath(\"/WEB-INF/classes/敏感词汇.txt\"); File file = new File(realPath); System.out.println(file.exists()); System.out.println(realPath); BufferedReader br = new BufferedReader(new FileReader(realPath)); String line = null; while ((line = br.readLine())!=null) &#123; list.add(line); &#125; System.out.println(list); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;Listener：监听器* 概念：web的三大组件之一。 * 事件监听机制 * 事件 ：一件事情 * 事件源 ：事件发生的地方 * 监听器 ：一个对象 * 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码 * ServletContextListener:监听ServletContext对象的创建和销毁 * 方法： * void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法 * void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法 * 步骤： 1. 定义一个类，实现ServletContextListener接口 2. 复写方法 3. 配置 1. web.xml &lt;listener&gt; &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; * 指定初始化参数&lt;context-param&gt; 2. 注解： * @WebListener","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"Response笔记","slug":"Response笔记","date":"2019-07-22T07:58:11.000Z","updated":"2020-06-04T00:57:09.295Z","comments":true,"path":"2019/07/22/Response笔记/","link":"","permalink":"https://wang-qp.github.io/2019/07/22/Response笔记/","excerpt":"","text":"HTTP协议：1. 请求消息：客户端发送给服务器端的数据 * 数据格式： 1. 请求行 2. 请求头 3. 请求空行 4. 请求体 2. 响应消息：服务器端发送给客户端的数据 * 数据格式： 1. 响应行 1. 组成：协议/版本 响应状态码 状态码描述 2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。 1. 状态码都是3位数字 2. 分类： 1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2. 2xx：成功。代表：200 3. 3xx：重定向。代表：302(重定向)，304(访问缓存) 4. 4xx：客户端错误。 * 代表： * 404（请求路径没有对应的资源） * 405：请求方式没有对应的doXxx方法 5. 5xx：服务器端错误。代表：500(服务器内部出现异常) 2. 响应头： 1. 格式：头名称： 值 2. 常见的响应头： 1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据 * 值： * in-line:默认值,在当前页面内打开 * attachment;filename=xxx：以附件形式打开响应体。文件下载 3. 响应空行 4. 响应体:传输的数据 * 响应字符串格式 HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Length: 101 Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt;Response对象* 功能：设置响应消息 1. 设置响应行 1. 格式：HTTP/1.1 200 ok 2. 设置状态码：setStatus(int sc) 2. 设置响应头：setHeader(String name, String value) 3. 设置响应体： * 使用步骤： 1. 获取输出流 * 字符输出流：PrintWriter getWriter() * 字节输出流：ServletOutputStream getOutputStream() 2. 使用输出流，将数据输出到客户端浏览器 * 案例： 1. 完成重定向 * 重定向：资源跳转的方式 * 代码实现： //1. 设置状态码为302 response.setStatus(302); //2.设置响应头location response.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;); //简单的重定向方法 response.sendRedirect(&quot;/day15/responseDemo2&quot;); * 重定向的特点:redirect 1. 地址栏发生变化 2. 重定向可以访问其他站点(服务器)的资源 3. 重定向是两次请求。不能使用request对象来共享数据 * 转发的特点：forward 1. 转发地址栏路径不变 2. 转发只能访问当前服务器下的资源 3. 转发是一次请求，可以使用request对象来共享数据 * forward 和 redirect 区别 * 路径写法： 1. 路径分类 1. 相对路径：通过相对路径不可以确定唯一资源 * 如：./index.html * 不以/开头，以.开头路径 * 规则：找到当前资源和目标资源之间的相对位置关系 * ./：当前目录 * ../:后退一级目录 2. 绝对路径：通过绝对路径可以确定唯一资源 * 如：http://localhost/day15/responseDemo2 /day15/responseDemo2 * 以/开头的路径 * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出 * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径) * 建议虚拟目录动态获取：request.getContextPath() * &lt;a&gt; , &lt;form&gt; 重定向... * 给服务器使用：不需要加虚拟目录 * 转发路径 2. 服务器输出字符数据到浏览器 * 步骤： 1. 获取字符输出流 2. 输出数据 * 注意： * 乱码问题： 1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1 2. 设置该流的默认编码 3. 告诉浏览器响应体使用的编码 //简单的形式，设置编码，是在获取流之前设置 response.setContentType(&quot;text/html;charset=utf-8&quot;); 3. 服务器输出字节数据到浏览器 * 步骤： 1. 获取字节输出流 2. 输出数据 4. 验证码 1. 本质：图片 2. 目的：防止恶意表单注册 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@WebServlet(\"/checkCodeServlet\")public class CheckCodeServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException &#123; //服务器通知浏览器不要缓存 response.setHeader(\"pragma\",\"no-cache\"); response.setHeader(\"cache-control\",\"no-cache\"); response.setHeader(\"expires\",\"0\"); //在内存中创建一个长80，宽30的图片，默认黑色背景 //参数一：长 //参数二：宽 //参数三：颜色 int width = 80; int height = 30; BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //获取画笔 Graphics g = image.getGraphics(); //设置画笔颜色为灰色 g.setColor(Color.GRAY); //填充图片 g.fillRect(0,0, width,height); //产生4个随机验证码，12Ey String checkCode = getCheckCode(); //将验证码放入HttpSession中 request.getSession().setAttribute(\"CHECKCODE_SERVER\",checkCode); //设置画笔颜色为黄色 g.setColor(Color.YELLOW); //设置字体的小大 g.setFont(new Font(\"黑体\",Font.BOLD,24)); //向图片上写入验证码 g.drawString(checkCode,15,25); //将内存中的图片输出到浏览器 //参数一：图片对象 //参数二：图片的格式，如PNG,JPG,GIF //参数三：图片输出到哪里去 ImageIO.write(image,\"PNG\",response.getOutputStream()); &#125; /** * 产生4位随机字符串 */ private String getCheckCode() &#123; String base = \"0123456789ABCDEFGabcdefg\"; int size = base.length(); Random r = new Random(); StringBuffer sb = new StringBuffer(); for(int i=1;i&lt;=4;i++)&#123; //产生0到size-1的随机值 int index = r.nextInt(size); //在base字符串中获取下标为index的字符 char c = base.charAt(index); //将c放入到StringBuffer中去 sb.append(c); &#125; return sb.toString(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request,response); &#125;&#125;ServletContext对象：1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信 2. 获取： 1. 通过request对象获取 request.getServletContext(); 2. 通过HttpServlet获取 this.getServletContext(); 3. 功能： 1. 获取MIME类型： * MIME类型:在互联网通信过程中定义的一种文件数据类型 * 格式： 大类型/小类型 text/html image/jpeg * 获取：String getMimeType(String file) 2. 域对象：共享数据 1. setAttribute(String name,Object value) 2. getAttribute(String name) 3. removeAttribute(String name) * ServletContext对象范围：所有用户所有请求的数据 3. 获取文件的真实(服务器)路径 1. 方法：String getRealPath(String path) String b = context.getRealPath(&quot;/b.txt&quot;);//web目录下资源访问 System.out.println(b); String c = context.getRealPath(&quot;/WEB-INF/c.txt&quot;);//WEB-INF目录下的资源访问 System.out.println(c); String a = context.getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);//src目录下的资源访问 System.out.println(a);案例：* 文件下载需求： 1. 页面显示超链接 2. 点击超链接后弹出下载提示框 3. 完成图片文件下载 * 分析： 1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求 2. 任何资源都必须弹出下载提示框 3. 使用响应头设置资源的打开方式： * content-disposition:attachment;filename=xxx * 步骤： 1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename 2. 定义Servlet 1. 获取文件名称 2. 使用字节输入流加载文件进内存 3. 指定response的响应头： content-disposition:attachment;filename=xxx 4. 将数据写出到response输出流 * 问题： * 中文文件问题 * 解决思路： 1. 获取客户端使用的浏览器版本信息 2. 根据不同的版本信息，设置filename的编码方式不同","categories":[],"tags":[],"keywords":[]},{"title":"Servlet&HTTP&Request笔记","slug":"Servlet-HTTP-Request笔记","date":"2019-07-22T07:48:14.000Z","updated":"2020-06-04T00:57:09.295Z","comments":true,"path":"2019/07/22/Servlet-HTTP-Request笔记/","link":"","permalink":"https://wang-qp.github.io/2019/07/22/Servlet-HTTP-Request笔记/","excerpt":"","text":"Servlet：1. 概念 2. 步骤 3. 执行原理 4. 生命周期 5. Servlet3.0 注解配置 6. Servlet的体系结构 Servlet -- 接口 | GenericServlet -- 抽象类 | HttpServlet -- 抽象类 * GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象 * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可 * HttpServlet：对http协议的一种封装，简化操作 1. 定义类继承HttpServlet 2. 复写doGet/doPost方法 7. Servlet相关配置 1. urlpartten:Servlet访问路径 1. 一个Servlet可以定义多个访问路径 ： @WebServlet({&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;}) 2. 路径定义规则： 1. /xxx：路径匹配 2. /xxx/xxx:多层路径，目录结构 3. *.do：扩展名匹配HTTP：* 概念：Hyper Text Transfer Protocol 超文本传输协议 * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式 * 特点： 1. 基于TCP/IP的高级协议 2. 默认端口号:80 3. 基于请求/响应模型的:一次请求对应一次响应 4. 无状态的：每次请求之间相互独立，不能交互数据 * 历史版本： * 1.0：每一次请求响应都会建立新的连接 * 1.1：复用连接 * 请求消息数据格式 1. 请求行 请求方式 请求url 请求协议/版本 GET /login.html HTTP/1.1 * 请求方式： * HTTP协议有7中请求方式，常用的有2种 * GET： 1. 请求参数在请求行中，在url后。 2. 请求的url长度有限制的 3. 不太安全 * POST： 1. 请求参数在请求体中 2. 请求的url长度没有限制的 3. 相对安全 2. 请求头：客户端浏览器告诉服务器一些信息 请求头名称: 请求头值 * 常见的请求头： 1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 2. Referer：http://localhost/login.html * 告诉服务器，我(当前请求)从哪里来？ * 作用： 1. 防盗链： 2. 统计工作： 3. 请求空行 空行，就是用于分割POST请求的请求头，和请求体的。 4. 请求体(正文)： * 封装POST请求消息的请求参数的 * 字符串格式： POST /login.html HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 username=zhangsan * 响应消息数据格式Request：1. request对象和response对象的原理 1. request和response对象是由服务器创建的。我们来使用它们 2. request对象是来获取请求消息，response对象是来设置响应消息 2. request对象继承体系结构： ServletRequest -- 接口 | 继承 HttpServletRequest -- 接口 | 实现 org.apache.catalina.connector.RequestFacade 类(tomcat) 3. request功能： 1. 获取请求消息数据 1. 获取请求行数据 * GET /day14/demo1?name=zhangsan HTTP/1.1 * 方法： 1. 获取请求方式 ：GET * String getMethod() 2. (*)获取虚拟目录：/day14 * String getContextPath() 3. 获取Servlet路径: /demo1 * String getServletPath() 4. 获取get方式请求参数：name=zhangsan * String getQueryString() 5. (*)获取请求URI：/day14/demo1 * String getRequestURI(): /day14/demo1 * StringBuffer getRequestURL() :http://localhost/day14/demo1 * URL:统一资源定位符 ： http://localhost/day14/demo1 中华人民共和国 * URI：统一资源标识符 : /day14/demo1 共和国 6. 获取协议及版本：HTTP/1.1 * String getProtocol() 7. 获取客户机的IP地址： * String getRemoteAddr() 2. 获取请求头数据 * 方法： * (*)String getHeader(String name):通过请求头的名称获取请求头的值 * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称 3. 获取请求体数据: * 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 * 步骤： 1. 获取流对象 * BufferedReader getReader()：获取字符输入流，只能操作字符数据 * ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 * 在文件上传知识点后讲解 2. 再从流对象中拿数据 2. 其他功能： 1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数 1. String getParameter(String name):根据参数名称获取参数值 username=zs&amp;password=123 2. String[] getParameterValues(String name):根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game 3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称 4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合 * 中文乱码问题： * get方式：tomcat 8 已经将get方式乱码问题解决了 * post方式：会乱码 * 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;); 2. 请求转发：一种在服务器内部的资源跳转方式 1. 步骤： 1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 2. 特点： 1. 浏览器地址栏路径不发生变化 2. 只能转发到当前服务器内部资源中。 3. 转发是一次请求 3. 共享数据： * 域对象：一个有作用范围的对象，可以在范围内共享数据 * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 * 方法： 1. void setAttribute(String name,Object obj):存储数据 2. Object getAttitude(String name):通过键获取值 3. void removeAttribute(String name):通过键移除键值对 4. 获取ServletContext： * ServletContext getServletContext()12345String url = request.getScheme()+\"://\"+ request.getServerName()+request.getRequestURI()+\"?\"+request.getQueryString();System.out.println(\"获取全路径（协议类型：//域名/项目名/命名空间/action名称?其他参数）url=\"+url);String url2=request.getScheme()+\"://\"+ request.getServerName();//+request.getRequestURI();System.out.println(\"协议名：//域名=\"+url2); 案例：用户登录* 用户登录案例需求： 1.编写login.html登录页面 username &amp; password 两个输入框 2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表 3.使用JdbcTemplate技术封装JDBC 4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您 5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误 * 分析 * 开发步骤 1. 创建项目，导入html页面，配置文件，jar包 2. 创建数据库环境 CREATE DATABASE day14; USE day14; CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32) UNIQUE NOT NULL, PASSWORD VARCHAR(32) NOT NULL ); 3. 创建包cn.itcast.domain,创建类User package cn.itcast.domain; /** * 用户的实体类 */ public class User { private int id; private String username; private String password; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, username=&apos;&quot; + username + &apos;\\&apos;&apos; + &quot;, password=&apos;&quot; + password + &apos;\\&apos;&apos; + &apos;}&apos;; } } 4. 创建包cn.itcast.util,编写工具类JDBCUtils package cn.itcast.util; import com.alibaba.druid.pool.DruidDataSourceFactory; import javax.sql.DataSource; import javax.xml.crypto.Data; import java.io.IOException; import java.io.InputStream; import java.sql.Connection; import java.sql.SQLException; import java.util.Properties; /** * JDBC工具类 使用Durid连接池 */ public class JDBCUtils { private static DataSource ds ; static { try { //1.加载配置文件 Properties pro = new Properties(); //使用ClassLoader加载配置文件，获取字节输入流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //2.初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(pro); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接池对象 */ public static DataSource getDataSource(){ return ds; } /** * 获取连接Connection对象 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); } } 5. 创建包cn.itcast.dao,创建类UserDao,提供login方法 package cn.itcast.dao; import cn.itcast.domain.User; import cn.itcast.util.JDBCUtils; import org.springframework.dao.DataAccessException; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; /** * 操作数据库中User表的类 */ public class UserDao { //声明JDBCTemplate对象共用 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 登录方法 * @param loginUser 只有用户名和密码 * @return user包含用户全部数据,没有查询到，返回null */ public User login(User loginUser){ try { //1.编写sql String sql = &quot;select * from user where username = ? and password = ?&quot;; //2.调用query方法 User user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), loginUser.getUsername(), loginUser.getPassword()); return user; } catch (DataAccessException e) { e.printStackTrace();//记录日志 return null; } } } 6. 编写cn.itcast.web.servlet.LoginServlet类 package cn.itcast.web.servlet; import cn.itcast.dao.UserDao; import cn.itcast.domain.User; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/loginServlet&quot;) public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.设置编码 req.setCharacterEncoding(&quot;utf-8&quot;); //2.获取请求参数 String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); //3.封装user对象 User loginUser = new User(); loginUser.setUsername(username); loginUser.setPassword(password); //4.调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); //5.判断user if(user == null){ //登录失败 req.getRequestDispatcher(&quot;/failServlet&quot;).forward(req,resp); }else{ //登录成功 //存储数据 req.setAttribute(&quot;user&quot;,user); //转发 req.getRequestDispatcher(&quot;/successServlet&quot;).forward(req,resp); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } } 7. 编写FailServlet和SuccessServlet类 @WebServlet(&quot;/successServlet&quot;) public class SuccessServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取request域中共享的user对象 User user = (User) request.getAttribute(&quot;user&quot;); if(user != null){ //给页面写一句话 //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 response.getWriter().write(&quot;登录成功！&quot;+user.getUsername()+&quot;,欢迎您&quot;); } } @WebServlet(&quot;/failServlet&quot;) public class FailServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //给页面写一句话 //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 response.getWriter().write(&quot;登录失败，用户名或密码错误&quot;); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 8. login.html中form表单的action路径的写法 * 虚拟目录+Servlet的资源路径 9. BeanUtils工具类，简化数据封装 * 用于封装JavaBean的 1. JavaBean：标准的Java类 1. 要求： 1. 类必须被public修饰 2. 必须提供空参的构造器 3. 成员变量必须使用private修饰 4. 提供公共setter和getter方法 2. 功能：封装数据 2. 概念： 成员变量： 属性：setter和getter方法截取后的产物 例如：getUsername() --&gt; Username--&gt; username 3. 方法： 1. setProperty() 2. getProperty() 3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"JDBC","slug":"JDBC","date":"2019-07-17T05:14:07.000Z","updated":"2020-06-04T00:57:09.293Z","comments":true,"path":"2019/07/17/JDBC/","link":"","permalink":"https://wang-qp.github.io/2019/07/17/JDBC/","excerpt":"","text":"数据库连接池1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 2. 好处： 1. 节约资源 2. 用户访问高效 3. 实现： 1. 标准接口：DataSource javax.sql包下的 1. 方法： * 获取连接：getConnection() * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接 2. 一般我们不去实现它，有数据库厂商来实现 1. C3P0：数据库连接池技术 2. Druid：数据库连接池实现技术，由阿里巴巴提供的 4. C3P0：数据库连接池技术 * 步骤： 1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ， * 不要忘记导入数据库驱动jar包 2. 定义配置文件： * 名称： c3p0.properties 或者 c3p0-config.xml * 路径：直接将文件放在src目录下即可。 3. 创建核心对象 数据库连接池对象 ComboPooledDataSource 4. 获取连接： getConnection * 代码： //1.创建数据库连接池对象 DataSource ds = new ComboPooledDataSource(); //2. 获取连接对象 Connection conn = ds.getConnection(); 5. Druid：数据库连接池实现技术，由阿里巴巴提供的 1. 步骤： 1. 导入jar包 druid-1.0.9.jar 2. 定义配置文件： * 是properties形式的 * 可以叫任意名称，可以放在任意目录下 3. 加载配置文件。Properties 4. 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory 5. 获取连接：getConnection * 代码： //3.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //4.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //5.获取连接 Connection conn = ds.getConnection(); 2. 定义工具类 1. 定义一个类 JDBCUtils 2. 提供静态代码块加载配置文件，初始化连接池对象 3. 提供方法 1. 获取连接方法：通过数据库连接池获取连接 2. 释放资源 3. 获取连接池的方法 * 代码： public class JDBCUtils { //1.定义成员变量 DataSource private static DataSource ds ; static{ try { //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;)); //2.获取DataSource ds = DruidDataSourceFactory.createDataSource(pro); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); } /** * 释放资源 */ public static void close(Statement stmt,Connection conn){ /* if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close();//归还连接 } catch (SQLException e) { e.printStackTrace(); } }*/ close(null,stmt,conn); } public static void close(ResultSet rs , Statement stmt, Connection conn){ if(rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close();//归还连接 } catch (SQLException e) { e.printStackTrace(); } } } /** * 获取连接池方法 */ public static DataSource getDataSource(){ return ds; } }Spring JDBC* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发 * 步骤： 1. 导入jar包 2. 创建JdbcTemplate对象。依赖于数据源DataSource * JdbcTemplate template = new JdbcTemplate(ds); 3. 调用JdbcTemplate的方法来完成CRUD的操作 * update():执行DML语句。增、删、改语句 * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 * 注意：这个方法查询的结果集长度只能是1 * queryForList():查询结果将结果集封装为list集合 * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 * query():查询结果，将结果封装为JavaBean对象 * query的参数：RowMapper * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 * new BeanPropertyRowMapper&lt;类型&gt;(类型.class) * queryForObject：查询结果，将结果封装为对象 * 一般用于聚合函数的查询 4. 练习： * 需求： 1. 修改1号数据的 salary 为 10000 2. 添加一条记录 3. 删除刚才添加的记录 4. 查询id为1的记录，将其封装为Map集合 5. 查询所有记录，将其封装为List 6. 查询所有记录，将其封装为Emp对象的List集合 7. 查询总记录数 * 代码： import cn.itcast.domain.Emp; import cn.itcast.utils.JDBCUtils; import org.junit.Test; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.RowMapper; import java.sql.Date; import java.sql.ResultSet; import java.sql.SQLException; import java.util.List; import java.util.Map; public class JdbcTemplateDemo2 { //Junit单元测试，可以让方法独立执行 //1. 获取JDBCTemplate对象 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 1. 修改1号数据的 salary 为 10000 */ @Test public void test1(){ //2. 定义sql String sql = &quot;update emp set salary = 10000 where id = 1001&quot;; //3. 执行sql int count = template.update(sql); System.out.println(count); } /** * 2. 添加一条记录 */ @Test public void test2(){ String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;; int count = template.update(sql, 1015, &quot;郭靖&quot;, 10); System.out.println(count); } /** * 3.删除刚才添加的记录 */ @Test public void test3(){ String sql = &quot;delete from emp where id = ?&quot;; int count = template.update(sql, 1015); System.out.println(count); } /** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */ @Test public void test4(){ String sql = &quot;select * from emp where id = ? or id = ?&quot;; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20} } /** * 5. 查询所有记录，将其封装为List */ @Test public void test5(){ String sql = &quot;select * from emp&quot;; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) { System.out.println(stringObjectMap); } } /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6(){ String sql = &quot;select * from emp&quot;; List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() { @Override public Emp mapRow(ResultSet rs, int i) throws SQLException { Emp emp = new Emp(); int id = rs.getInt(&quot;id&quot;); String ename = rs.getString(&quot;ename&quot;); int job_id = rs.getInt(&quot;job_id&quot;); int mgr = rs.getInt(&quot;mgr&quot;); Date joindate = rs.getDate(&quot;joindate&quot;); double salary = rs.getDouble(&quot;salary&quot;); double bonus = rs.getDouble(&quot;bonus&quot;); int dept_id = rs.getInt(&quot;dept_id&quot;); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; } }); for (Emp emp : list) { System.out.println(emp); } } /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6_2(){ String sql = &quot;select * from emp&quot;; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) { System.out.println(emp); } } /** * 7. 查询总记录数 */ @Test public void test7(){ String sql = &quot;select count(id) from emp&quot;; Long total = template.queryForObject(sql, Long.class); System.out.println(total); } }","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"MySQL基础语法","slug":"MySQL基础语法","date":"2019-07-15T11:08:26.000Z","updated":"2020-06-04T00:57:09.294Z","comments":true,"path":"2019/07/15/MySQL基础语法/","link":"","permalink":"https://wang-qp.github.io/2019/07/15/MySQL基础语法/","excerpt":"","text":"DDL:操作数据库、表1. 操作数据库：CRUD 1. C(Create):创建 * 创建数据库： * create database 数据库名称; * 创建数据库，判断不存在，再创建： * create database if not exists 数据库名称; * 创建数据库，并指定字符集 * create database 数据库名称 character set 字符集名; * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk * create database if not exists db4 character set gbk; 2. R(Retrieve)：查询 * 查询所有数据库的名称: * show databases; * 查询某个数据库的字符集:查询某个数据库的创建语句 * show create database 数据库名称; 3. U(Update):修改 * 修改数据库的字符集 * alter database 数据库名称 character set 字符集名称; 4. D(Delete):删除 * 删除数据库 * drop database 数据库名称; * 判断数据库存在，存在再删除 * drop database if exists 数据库名称; 5. 使用数据库 * 查询当前正在使用的数据库名称 * select database(); * 使用数据库 * use 数据库名称; 2. 操作表 1. C(Create):创建 1. 语法： create table 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); * 注意：最后一列，不需要加逗号（,） * 数据库类型： 1. int：整数类型 * age int, 2. double:小数类型 * score double(5,2) 3. date:日期，只包含年月日，yyyy-MM-dd 4. datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 5. timestamp:时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 6. varchar：字符串 * name varchar(20):姓名最大20个字符 * zhangsan 8个字符 张三 2个字符 * 创建表 create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); * 复制表： * create table 表名 like 被复制的表名; 2. R(Retrieve)：查询 * 查询某个数据库中所有的表名称 * show tables; * 查询表结构 * desc 表名; 3. U(Update):修改 1. 修改表名 alter table 表名 rename to 新的表名; 2. 修改表的字符集 alter table 表名 character set 字符集名称; 3. 添加一列 alter table 表名 add 列名 数据类型; 4. 修改列名称 类型 alter table 表名 change 列名 新列别 新数据类型; alter table 表名 modify 列名 新数据类型; 5. 删除列 alter table 表名 drop 列名; 4. D(Delete):删除 * drop table 表名; * drop table if exists 表名 ;数据库的备份和还原* 语法： * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 * 还原： 1. 登录数据库 2. 创建数据库 3. 使用数据库 4. 执行文件。source 文件路径基础语法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970CREATE TABLE student ( id INT, -- 编号 NAME VARCHAR(20), -- 姓名 age INT, -- 年龄 sex VARCHAR(5), -- 性别 address VARCHAR(100), -- 地址 math INT, -- 数学 english INT -- 英语);INSERT INTO student(id,NAME,age,sex,address,math,english) VALUES (1,'马云',55,'男','杭州',66,78),(2,'马化腾',45,'女','深圳',98,87),(3,'马景涛',55,'男','香港',56,77),(4,'柳岩',20,'女','湖南',76,65),(5,'柳青',20,'男','湖南',86,NULL),(6,'刘德华',57,'男','香港',99,99),(7,'马德',22,'女','香港',99,99),(8,'德玛西亚',18,'男','南京',56,65);UPDATE student SET id = 003 WHERE id = 1;DELETE FROM student WHERE id=1;DROP TABLE student;TRUNCATE TABLE student;-- 查询姓名和年龄SELECT NAME,age FROM student;-- 去除重复的结果集SELECT DISTINCT address FROM student;-- 计算 math 和 English 的和SELECT NAME,math,english,math+english FROM student;-- 如果有null 参与运算，结果都为nullSELECT NAME,math,english,math+IFNULL(english,0) FROM student;-- 起别名SELECT NAME,math,english,math+IFNULL(english,0) AS 总分 FROM student;SELECT NAME,math 数学,english 英语,math+IFNULL(english,0) 总分 FROM student;-- 查询年龄大于20SELECT * FROM student WHERE age &gt;= 20;-- 查询年龄大于20SELECT * FROM student WHERE age != 20;SELECT * FROM student WHERE age &lt;&gt; 20;-- 查询年龄再20和30之间SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30;SELECT * FROM student WHERE age &gt;= 20 AND age &lt;= 30;SELECT * FROM student WHERE age BETWEEN 20 AND 30;-- 查询年龄为18,22,25SELECT * FROM student WHERE age = 18 OR age = 22 OR age = 25;SELECT * FROM student WHERE age IN (18,22,25);-- 查询是否为null， 不能使用=(!=)SELECT * FROM student WHERE english IS NULL;SELECT * FROM student WHERE english IS NOT NULL;-- 查询姓名第二个字是“化”SELECT * FROM student WHERE NAME LIKE \"_化%\";-- 查询姓名是三个字的SELECT * FROM student WHERE NAME LIKE '___';-- 查询姓名含有“德”的SELECT * FROM student WHERE NAME LIKE \"%德%\";-- 排序SELECT * FROM student ORDER BY math DESC , english ASC;-- 聚合函数（纵向计算）SELECT COUNT(IFNULL(english,0)) FROM student;SELECT MAX(english) FROM student;SELECT MIN(english) FROM student;SELECT SUM(english) FROM student;SELECT AVG(english) FROM student;-- 分组查询SELECT sex,AVG(english),COUNT(id) FROM student GROUP BY sex;SELECT sex,AVG(english),COUNT(id) FROM student WHERE english &gt; 70 GROUP BY sex;SELECT sex,AVG(english),COUNT(id) FROM student WHERE english &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;-- 分页SELECT * FROM student LIMIT 3,3; 约束条件1234567891011121314151617181920212223242526272829303132CREATE TABLE obj( id INT PRIMARY KEY, NAME VARCHAR(10) DEFAULT \"数学\");CREATE TABLE st( id INT PRIMARY KEY, NAME VARCHAR(20) NOT NULL, number VARCHAR(20), uid INT, CONSTRAINT uk FOREIGN KEY (uid) REFERENCES obj(id));-- 删除非空ALTER TABLE st MODIFY NAME VARCHAR(10);ALTER TABLE st MODIFY NAME VARCHAR(20) NOT NULL;-- 唯一约束ALTER TABLE st MODIFY number INT UNIQUE;-- 删除唯一约束ALTER TABLE st DROP INDEX number ; -- 删除主键ALTER TABLE st DROP PRIMARY KEY;-- 添加主键ALTER TABLE st MODIFY id INT PRIMARY KEY;-- 添加自动增长ALTER TABLE st MODIFY id INT AUTO_INCREMENT;-- 删除自动增长ALTER TABLE st MODIFY id INT;-- 删除外键ALTER TABLE st DROP FOREIGN KEY uk;-- 添加外键,设置级联更新ALTER TABLE st ADD CONSTRAINT uk FOREIGN KEY (uid) REFERENCES obj(id) ON UPDATE CASCADE; -- ON DELETE CASCADE 多表查询： 多表查询的分类： 内连接查询： 隐式内连接：使用where条件消除无用数据 例子：SELECT t1.name, – 员工表的姓名 t1.gender,– 员工表的性别 t2.name – 部门表的名称FROM emp t1, dept t2WHERE t1.dept_id = t2.id; 2. 显式内连接： * 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件 * 例如： * SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`; * SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`; 3. 内连接查询： 1. 从哪些表中查询数据 2. 条件是什么 3. 查询哪些字段 2. 外链接查询： 1. 左外连接： * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件； * 查询的是左表所有数据以及其交集部分。 * 例子： -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称 SELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`; 2. 右外连接： * 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件； * 查询的是右表所有数据以及其交集部分。 * 例子： SELECT * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`; 3. 子查询： * 概念：查询中嵌套查询，称嵌套查询为子查询。 -- 查询工资最高的员工信息 -- 1 查询最高的工资是多少 9000 SELECT MAX(salary) FROM emp; -- 2 查询员工信息，并且工资等于9000的 SELECT * FROM emp WHERE emp.`salary` = 9000; -- 一条sql就完成这个操作。子查询 SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp); * 子查询不同情况 1. 子查询的结果是单行单列的： * 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= = * -- 查询员工工资小于平均工资的人 SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp); 2. 子查询的结果是多行单列的： * 子查询可以作为条件，使用运算符in来判断 -- 查询&apos;财务部&apos;和&apos;市场部&apos;所有的员工信息 SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;; SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2; -- 子查询 SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;); 3. 子查询的结果是多行多列的： * 子查询可以作为一张虚拟表参与查询 -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息 -- 子查询 SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &apos;2011-11-11&apos;) t2 WHERE t1.id = t2.dept_id; -- 普通内连接 SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt; &apos;2011-11-11&apos;事务1. 事务的基本介绍 1. 概念： * 如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 2. 操作： 1. 开启事务： start transaction; 2. 回滚：rollback; 3. 提交：commit; 3. 例子： CREATE TABLE account ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), balance DOUBLE ); -- 添加数据 INSERT INTO account (NAME, balance) VALUES (&apos;zhangsan&apos;, 1000), (&apos;lisi&apos;, 1000); SELECT * FROM account; UPDATE account SET balance = 1000; -- 张三给李四转账 500 元 -- 0. 开启事务 START TRANSACTION; -- 1. 张三账户 -500 UPDATE account SET balance = balance - 500 WHERE NAME = &apos;zhangsan&apos;; -- 2. 李四账户 +500 -- 出错了... UPDATE account SET balance = balance + 500 WHERE NAME = &apos;lisi&apos;; -- 发现执行没有问题，提交事务 COMMIT; -- 发现出问题了，回滚事务 ROLLBACK; 4. MySQL数据库中事务默认自动提交 * 事务提交的两种方式： * 自动提交： * mysql就是自动提交的 * 一条DML(增删改)语句会自动提交一次事务。 * 手动提交： * Oracle 数据库默认是手动提交事务 * 需要先开启事务，再提交 * 修改事务的默认提交方式： * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交 0 代表手动提交 * 修改默认提交方式： set @@autocommit = 0; 2. 事务的四大特征： 1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。 2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。 3. 隔离性：多个事务之间。相互独立。 4. 一致性：事务操作前后，数据总量不变 3. 事务的隔离级别（了解） * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。 * 存在问题： 1. 脏读：一个事务，读取到另一个事务中没有提交的数据 2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。 3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 * 隔离级别： 1. read uncommitted：读未提交 * 产生的问题：脏读、不可重复读、幻读 2. read committed：读已提交 （Oracle） * 产生的问题：不可重复读、幻读 3. repeatable read：可重复读 （MySQL默认） * 产生的问题：幻读 4. serializable：串行化 * 可以解决所有的问题 * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 * 数据库查询隔离级别： * select @@tx_isolation; * 数据库设置隔离级别： * set global transaction isolation level 级别字符串; * 演示： set global transaction isolation level read uncommitted; start transaction; -- 转账操作 update account set balance = balance - 500 where id = 1; update account set balance = balance + 500 where id = 2;DCL：* SQL分类： 1. DDL：操作数据库和表 2. DML：增删改表中数据 3. DQL：查询表中数据 4. DCL：管理用户，授权 * DBA：数据库管理员 * DCL：管理用户，授权 1. 管理用户 1. 添加用户： * 语法：CREATE USER &apos;用户名&apos;@&apos;主机名&apos; IDENTIFIED BY &apos;密码&apos;; 2. 删除用户： * 语法：DROP USER &apos;用户名&apos;@&apos;主机名&apos;; 3. 修改用户密码： UPDATE USER SET PASSWORD = PASSWORD(&apos;新密码&apos;) WHERE USER = &apos;用户名&apos;; UPDATE USER SET PASSWORD = PASSWORD(&apos;abc&apos;) WHERE USER = &apos;lisi&apos;; SET PASSWORD FOR &apos;用户名&apos;@&apos;主机名&apos; = PASSWORD(&apos;新密码&apos;); SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123&apos;); * mysql中忘记了root用户的密码？ 1. cmd -- &gt; net stop mysql 停止mysql服务 * 需要管理员运行该cmd 2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables 3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功 4. use mysql; 5. update user set password = password(&apos;你的新密码&apos;) where user = &apos;root&apos;; 6. 关闭两个窗口 7. 打开任务管理器，手动结束mysqld.exe 的进程 8. 启动mysql服务 9. 使用新密码登录。 4. 查询用户： -- 1. 切换到mysql数据库 USE myql; -- 2. 查询user表 SELECT * FROM USER; * 通配符： % 表示可以在任意主机使用用户登录数据库 2. 权限管理： 1. 查询权限： -- 查询权限 SHOW GRANTS FOR &apos;用户名&apos;@&apos;主机名&apos;; SHOW GRANTS FOR &apos;lisi&apos;@&apos;%&apos;; 2. 授予权限： -- 授予权限 grant 权限列表 on 数据库名.表名 to &apos;用户名&apos;@&apos;主机名&apos;; -- 给张三用户授予所有权限，在任意数据库任意表上 GRANT ALL ON *.* TO &apos;zhangsan&apos;@&apos;localhost&apos;; 3. 撤销权限： -- 撤销权限： revoke 权限列表 on 数据库名.表名 from &apos;用户名&apos;@&apos;主机名&apos;; REVOKE UPDATE ON db3.`account` FROM &apos;lisi&apos;@&apos;%&apos;;","categories":[{"name":"SQL","slug":"SQL","permalink":"https://wang-qp.github.io/categories/SQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://wang-qp.github.io/tags/MySQL/"}],"keywords":[{"name":"SQL","slug":"SQL","permalink":"https://wang-qp.github.io/categories/SQL/"}]},{"title":"lock锁","slug":"lock锁","date":"2019-07-11T15:05:05.000Z","updated":"2020-06-04T00:57:09.306Z","comments":true,"path":"2019/07/11/lock锁/","link":"","permalink":"https://wang-qp.github.io/2019/07/11/lock锁/","excerpt":"","text":"###lock锁基础 12345678910111213141516171819202122232425262728293031323334353637383940package cn.wang.d07_thread.t02_safe;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class pay implements Runnable&#123; private int piao = 100; //创建锁对象 Lock l = new ReentrantLock(); @Override public void run() &#123; while (true) &#123; //调用锁方法 l.lock(); if (piao &gt; 0) &#123; try &#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName() + \"--&gt;\" + piao--); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; //在finally解锁，可以使无论是否异常都解锁 l.unlock(); &#125; &#125; &#125; &#125;&#125;public class lock_test &#123; public static void main(String[] args) &#123; pay piao = new pay(); Thread t1 = new Thread(piao); Thread t2 = new Thread(piao); Thread t3 = new Thread(piao); t1.start(); t2.start(); t3.start(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"同步代码块和同步方法","slug":"同步代码块和同步方法","date":"2019-07-11T15:03:46.000Z","updated":"2020-06-04T00:57:09.311Z","comments":true,"path":"2019/07/11/同步代码块和同步方法/","link":"","permalink":"https://wang-qp.github.io/2019/07/11/同步代码块和同步方法/","excerpt":"","text":"##java线程基础 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Piao implements Runnable&#123; private static int piao = 100; Object obj = new Object(); //静态方法用的是本类class的属性--&gt;class文件对象（反射） private static /*synchronized*/ void staticfunc()&#123; synchronized (Runnable.class)&#123; if(piao&gt;0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"--&gt;\" + piao--); &#125; &#125; &#125; @Override public void run() &#123; while(true)&#123;// func(); staticfunc();// synchronized (obj)&#123;// if(piao&gt;0)&#123;// try &#123;// Thread.sleep(100);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;// System.out.println(Thread.currentThread().getName()+\"--&gt;\"+piao--);// &#125;else &#123;// break;// &#125;// &#125; &#125; &#125; private /*synchronized*/ void func()&#123; synchronized (this)&#123; if(piao&gt;0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"--&gt;\"+piao--); &#125; &#125; &#125;&#125;public class synchronized_test &#123; public static void main(String[] args) &#123; Piao piao = new Piao(); Thread t1 = new Thread(piao); Thread t2 = new Thread(piao); Thread t3 = new Thread(piao); t1.start(); t2.start(); t3.start(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://wang-qp.github.io/categories/java/"}]},{"title":"线段树","slug":"线段树","date":"2019-06-27T04:04:32.000Z","updated":"2020-06-04T00:57:09.311Z","comments":true,"path":"2019/06/27/线段树/","link":"","permalink":"https://wang-qp.github.io/2019/06/27/线段树/","excerpt":"","text":"##线段树基础使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;struct shu&#123; int l; int r; int n;&#125;p[150050];void init(int l,int r,int rt)&#123; if(l==r) &#123; p[rt].l=l; p[rt].r=r; p[rt].n=0; return ; &#125; int mid=(l+r)&gt;&gt;1; p[rt].l=l; p[rt].r=r; p[rt].n=0; init(l,mid,rt&lt;&lt;1); init(mid+1,r,rt&lt;&lt;1|1);&#125;void f(int n,int s,int k)&#123; if(p[k].l==p[k].r&amp;&amp;p[k].l==n) &#123; p[k].n+=s; return ; &#125; int mid=(p[k].l+p[k].r)&gt;&gt;1; if(n&lt;=mid) f(n,s,k&lt;&lt;1); else f(n,s,k&lt;&lt;1|1); p[k].n=p[k&lt;&lt;1].n+p[k&lt;&lt;1|1].n;&#125;int s;void ff(int l,int r,int k)&#123; if(p[k].l==l&amp;&amp;p[k].r==r) &#123; s+=p[k].n; return ; &#125; int mid=(p[k].l+p[k].r)&gt;&gt;1; if(r&lt;=mid) ff(l,r,k&lt;&lt;1); else if(l&gt;mid) ff(l,r,k&lt;&lt;1|1); else &#123; ff(l,mid,k&lt;&lt;1); ff(mid+1,r,k&lt;&lt;1|1); &#125;&#125;int main()&#123; int T,n,a,i,b,c; char w[10]; while(~scanf(\"%d\",&amp;T)) &#123; c=1; while(T--) &#123; s=0; scanf(\"%d\",&amp;n); init(1,n,1); for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;a); f(i,a,1); &#125; printf(\"Case %d:\\n\",c++); while(1) &#123; scanf(\"%s\",w); if(w[0]=='E') break; scanf(\"%d%d\",&amp;a,&amp;b); if(w[0]=='A') f(a,b,1); if(w[0]=='S') f(a,-b,1); if(w[0]=='Q') &#123; s=0; ff(a,b,1); printf(\"%d\\n\",s); &#125; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://wang-qp.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wang-qp.github.io/tags/算法/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://wang-qp.github.io/categories/算法/"}]},{"title":"wordcloud","slug":"wordcloud","date":"2019-06-24T00:36:08.000Z","updated":"2020-06-04T00:57:09.310Z","comments":true,"path":"2019/06/24/wordcloud/","link":"","permalink":"https://wang-qp.github.io/2019/06/24/wordcloud/","excerpt":"","text":"##wordcloud常用操作 123456789101112131415161718192021222324252627282930313233from wordcloud import WordCloud, ImageColorGeneratorimport jiebaimport imageiofrom matplotlib import pyplot as pltimg = imageio.imread('1.png')imgcolor = ImageColorGenerator(img)w = WordCloud(width=500, height=500, background_color=\"white\", font_path=\"msyh.ttc\", mask=img, scale=15, stopwords=&#123;'不想展示的词'&#125;, contour_width=1, contour_color='blue')text = \"计算机科学与技术\"text = jieba.lcut(text)text = \" \".join(text)w.generate(text)fig, axes = plt.subplots(1,3)axes[0].imshow(w)axes[1].imshow(w.recolor(color_func=imgcolor),interpolation=\"bilinear\")axes[2].imshow(img,cmap=plt.cm.gray)for ax in axes: ax.set_axis_off()plt.show()w1 = w.recolor(color_func=imgcolor)w.to_file(\"2.png\")","categories":[{"name":"python","slug":"python","permalink":"https://wang-qp.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wang-qp.github.io/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"https://wang-qp.github.io/categories/python/"}]},{"title":"selenium","slug":"selenium","date":"2019-06-10T13:33:38.000Z","updated":"2020-06-04T00:57:09.309Z","comments":true,"path":"2019/06/10/selenium/","link":"","permalink":"https://wang-qp.github.io/2019/06/10/selenium/","excerpt":"","text":"###selenium基础使用 123456789101112131415161718192021222324252627282930313233343536from selenium import webdriverfrom selenium.webdriver.support.select import Selectimport timedriver = webdriver.Chrome(executable_path=\"E:\\\\Code\\\\python\\\\scrapy\\\\chromedriver.exe\")driver.fullscreen_window() # 最大化'''driver.get(\"http://www.baidu.com\")driver.find_element_by_id(\"kw\").send_keys(\"python\") # 输入值driver.find_element_by_id(\"su\").click() # 点击# driver.minimize_window()# driver.maximize_window()title = driver.title # 标题print(title)url = driver.current_url # 网址print(url)driver.back() # 上一页page = driver.page_source # 网页源代码print(page)driver.forward() # 下一页driver.close() # 关闭当前标签页# driver.quit()#关闭浏览器''''''#选择器driver.get(\"https://wannianrili.51240.com/\")year = driver.find_element_by_id(\"wnrl_xuanze_nian\")year = Select(year)year.select_by_visible_text(\"1997\")'''#截图driver.get(\"https://www.baidu.com\")driver.save_screenshot(r\"C:\\Users\\Administrator\\Desktop\\截图.png\")driver.close()","categories":[{"name":"python","slug":"python","permalink":"https://wang-qp.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wang-qp.github.io/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"https://wang-qp.github.io/categories/python/"}]},{"title":"Centos下安装maven","slug":"mven","date":"2019-06-01T04:04:32.000Z","updated":"2020-06-04T00:57:09.306Z","comments":true,"path":"2019/06/01/mven/","link":"","permalink":"https://wang-qp.github.io/2019/06/01/mven/","excerpt":"","text":"Centos下安装maven1、maven下载地址：https://maven.apache.org/download.cgi 下载 apache-maven-3.6.1-bin.tar.gz 2、在linux环境中创建maven目录，/opt/myjava/maven，将maven安装包上传至此目录中解压 1tar -zxvf apache-maven-3.6.1-bin.tar.gz 3、配置环境变量 1vim /etc/profile 将下面这两行代码拷贝到文件末尾并保存 12export MAVEN_HOME=/opt/myjava/maven/apache-maven-3.6.1export PATH=$&#123;MAVEN_HOME&#125;/bin:$&#123;PATH&#125; 重载环境变量 1source /etc/profile 4、查看结果 1mvn -v 5、替换maven源，阿里云的源 打开maven配置文件，比如： 1vim /opt/myjava/maven/apache-maven-3.6.1/conf/settings.xml 找到标签对，添加一下代码： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; 6、指定下载资源位置 1&lt;localRepository&gt;/opt/myjava/maven_repository&lt;/localRepository&gt; 7、指定JDK版本 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt;","categories":[{"name":"其他","slug":"其他","permalink":"https://wang-qp.github.io/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://wang-qp.github.io/tags/其他/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://wang-qp.github.io/categories/其他/"}]},{"title":"spider_header","slug":"spider_header","date":"2019-05-15T00:04:37.000Z","updated":"2020-06-04T00:57:09.310Z","comments":true,"path":"2019/05/15/spider_header/","link":"","permalink":"https://wang-qp.github.io/2019/05/15/spider_header/","excerpt":"","text":"###请求头设置 1234567891011121314151617181920212223242526272829303132333435363738394041import requestsimport timefrom lxml import etreebase_url = 'http://yuanjian.cnki.net/Search/ListResult'headers=&#123; 'Host':'yuanjian.cnki.net', 'Referer':'http://yuanjian.cnki.net/Search/ListResult', 'User_Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.108 Safari/537.36'&#125;Listkey=[]Listhref=[]param = &#123; 'searchType': 'MulityTermsSearch', 'Order': 2, 'KeyWord' : \"\", 'Page': 1&#125;def post_page(key): param[\"KeyWord\"]=key index=1 while True: param[\"Page\"]=index request=requests.post(base_url,data=param,headers=headers) html = etree.HTML(request.text) href = html.xpath('//p[@class=\"tit clearfix\"]/a[@class=\"left\"]/@href') for i in href: if i not in Listhref: Listhref.append(i) else: return None index=index+1 time.sleep(5)if __name__ == \"__main__\": str=post_page(\"MXD6\") print(len(Listhref)) html = Listhref[0] html = requests.get(Listhref[0]).text print(html)","categories":[{"name":"python","slug":"python","permalink":"https://wang-qp.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wang-qp.github.io/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"https://wang-qp.github.io/categories/python/"}]},{"title":"树状数组","slug":"树状数组","date":"2019-04-22T10:12:54.000Z","updated":"2020-06-04T00:57:09.311Z","comments":true,"path":"2019/04/22/树状数组/","link":"","permalink":"https://wang-qp.github.io/2019/04/22/树状数组/","excerpt":"","text":"##树状树组基础使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=100009;const ll md=998244353;int n,m;inline int read()&#123; int x=0;char ch=getchar(); while(ch&lt;'0' || '9'&lt;ch)ch=getchar(); while('0'&lt;=ch &amp;&amp; ch&lt;='9')x=x*10+(ch^48),ch=getchar(); return x;&#125;inline ll qpow(ll a,ll b=md-2)&#123; ll ret=1; while(b) &#123; if(b&amp;1) ret=ret*a%md; a=a*a%md; b&gt;&gt;=1; &#125; return ret;&#125;inline ll merge(ll p1,ll p2)&#123; return (p1*p2%md+(1+md-p2)*(1+md-p1)%md)%md;&#125;namespace sseg&#123; int ch[N&lt;&lt;8][2],rt[N&lt;&lt;2],tot=1; ll val[N&lt;&lt;8]; inline void add(int &amp;x,int l,int r,int dl,int dr,ll v) &#123; if(!x)x=++tot,val[x]=1; if(dl==l &amp;&amp; r==dr)&#123;val[x]=merge(val[x],v);return;&#125; int mid=l+r&gt;&gt;1; if(dr&lt;=mid) add(ch[x][0],l,mid,dl,dr,v); else if(mid&lt;dl) add(ch[x][1],mid+1,r,dl,dr,v); else &#123; add(ch[x][0],l,mid,dl,mid,v); add(ch[x][1],mid+1,r,mid+1,dr,v); &#125; &#125; inline ll qsum(int x,int l,int r,int p) &#123; if(!x)return 1; if(l==r)return val[x]; int mid=l+r&gt;&gt;1; if(p&lt;=mid)return merge(val[x],qsum(ch[x][0],l,mid,p)); else return merge(val[x],qsum(ch[x][1],mid+1,r,p)); &#125; inline void modify(int x,int l,int r,int dl,int dr,int nl,int nr,ll v) &#123; if(dl==l &amp;&amp; r==dr)&#123;add(rt[x],1,n,nl,nr,v);return;&#125; int mid=l+r&gt;&gt;1; if(dr&lt;=mid) modify(x&lt;&lt;1,l,mid,dl,dr,nl,nr,v); else if(mid&lt;dl) modify(x&lt;&lt;1|1,mid+1,r,dl,dr,nl,nr,v); else &#123; modify(x&lt;&lt;1,l,mid,dl,mid,nl,nr,v); modify(x&lt;&lt;1|1,mid+1,r,mid+1,dr,nl,nr,v); &#125; &#125; inline ll query(int x,int l,int r,int px,int py) &#123; if(l==r)return qsum(rt[x],1,n,py);int mid=l+r&gt;&gt;1; if(px&lt;=mid)return merge(qsum(rt[x],1,n,py),query(x&lt;&lt;1,l,mid,px,py)); else return merge(qsum(rt[x],1,n,py),query(x&lt;&lt;1|1,mid+1,r,px,py)); &#125;&#125;int main()&#123; int root=1; n=read();m=read(); for(int i=1;i&lt;=m;i++) &#123; if(read()==1) &#123; int l=read(),r=read();ll inv=qpow(r-l+1); if(l-1) &#123; sseg::modify(root,0,n,1,l-1,l,r,(1+md-inv)%md); sseg::modify(root,0,n,0,0,1,l-1,0); &#125; if(r&lt;n) &#123; sseg::modify(root,0,n,l,r,r+1,n,(1+md-inv)%md); sseg::modify(root,0,n,0,0,r+1,n,0); &#125; sseg::modify(root,0,n,l,r,l,r,(1+md-2*inv%md)%md); sseg::modify(root,0,n,0,0,l,r,inv); &#125; else &#123; int l=read(),r=read(); printf(\"%lld\\n\",sseg::query(1,0,n,l-1,r)); &#125; &#125; return 0;&#125; 参考","categories":[{"name":"算法","slug":"算法","permalink":"https://wang-qp.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wang-qp.github.io/tags/算法/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://wang-qp.github.io/categories/算法/"}]},{"title":"spider","slug":"spider","date":"2019-04-21T07:18:16.000Z","updated":"2020-06-04T00:57:09.309Z","comments":true,"path":"2019/04/21/spider/","link":"","permalink":"https://wang-qp.github.io/2019/04/21/spider/","excerpt":"","text":"##获取拉链详情保持到本地excal 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134from urllib.request import*from lxml import etreeimport reimport osimport timeimport xlwtfrom xlutils.copy import copyimport xlrddef imgdownload(imgurl,filename,name): #下载图片 try: print(\"下载。。。%s\"%name) imgurl = imgurl.replace(\" \",\"%20\") #将空白符替换成\"%20\" urlretrieve(imgurl, \".\\\\%s\\\\%s.jpg\" % (filename, name)) except Exception as e: print(\"=\"*70) print(\"下载异常详情：\") print(e) print(\"图片名：%s\\t图片地址：%s\"%(name,imgurl)) print(\"=\"*70)def excel(index,detailed_information): book1 = xlrd.open_workbook('ykk.xls') book2 = copy(book1) excel_sheet = book2.get_sheet(0) colIndex = 0 excel_headDatas = [\"商品名称\", \"商品类型\", \"商品链接\", \"商品简介\", \"商品用途\", \"注意事项\"] for item in excel_headDatas: excel_sheet.write(index, colIndex, detailed_information[item]) colIndex += 1 book2.save('ykk.xls')def new_excel(): excel_headDatas = [\"商品名称\", \"商品类型\", \"商品链接\", \"商品简介\", \"商品用途\", \"注意事项\"] excle_Workbook = xlwt.Workbook() excel_sheet = excle_Workbook.add_sheet(\"拉链\") index = 0 for data in excel_headDatas: excel_sheet.write(0, index, data) index += 1 excle_Workbook.save('ykk.xls')def look_details(details_urls): di = 1 line = 1 new_excel() gong = len(details_urls) for details_url in details_urls: name = details_url[\"name\"] stype = details_url[\"stype\"] url = details_url[\"url\"] try: print(\"=\"*100) print(\"第%d/%d个网页\"%(di,gong)) print(name) print(stype) print(url) html = urlopen(url).read().decode(\"utf-8\") html = etree.HTML(html) #简介 intro = '' intro_div = html.xpath('//div[@class=\"ProductInfo\"]') for string in intro_div[0].xpath('.//div[@class=\"text\"]/text()'): string = string.strip() intro += string print(intro) #用途 use = [] useul = html.xpath('//ul[@class=\"layoutItem col4 flexed\"]//text()') print(useul) for i in useul: i = i.replace(\"\\n\",'').strip() if i: use.append(i) use = '、'.join(use) print(use) #注意事项 announcements = '' andiv = html.xpath('//div[@class=\"area clearfix\"]')[0] andivs = etree.tostring(andiv, encoding=\"utf-8\").decode(\"utf-8\") subdiv = re.findall('&lt;h2&gt;注意事项((.|\\s)*?)&lt;/div&gt;', andivs) if len(subdiv)!=0: subdiv = subdiv[0][0] parser = etree.HTMLParser(encoding=\"utf-8\") subdiv = etree.HTML(subdiv, parser=parser) # subdiv = etree.tostring(subdiv,encoding=\"utf-8\").decode(\"utf-8\") text = subdiv.xpath('.//div//text()') announcements = ''.join(text) print(announcements) dic = &#123;\"商品名称\":name,\"商品类型\":stype,\"商品链接\":url,\"商品简介\":intro,\"商品用途\":use,\"注意事项\":announcements&#125; excel(line,dic) line += 1 except Exception as e: print(\"=\"*50) print(\"访问异常详情：\") print(e) print(\"异常网址：%s\"%url) print(\"=\"*50) finally: di += 1 print(\"=\"*100) time.sleep(10)def open_dict_url(urls): details_urls = [] for i in urls: filename = i[\"name\"] if not os.path.exists(\".\\\\%s\"%filename): os.mkdir(\".\\\\%s\"%filename) for index in range(1,3): url = i[\"url\"] + str(index) print(url) html = urlopen(url).read().decode(\"utf-8\") html = etree.HTML(html) result = html.xpath('//div[@class=\"ProductItems\"]') for div in result: imgurl = \"https://www.ykkfastening.com\" + div.xpath('.//img/@src')[0] url = \"https://www.ykkfastening.com\" + div.xpath('.//a/@href')[0] name = div.xpath('.//a/text()')[0].replace(' ','') name = re.sub('/|\\\\|\\||\\?|\\*|\"|&lt;|&gt;','_',name) #文件名不能出现符号 details_urls.append(&#123;\"name\":name,\"stype\":filename,\"url\":url&#125;) imgdownload(imgurl,filename,name) look_details(details_urls)if __name__ == \"__main__\": headers = (\"User-Agent\",\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\") opener = build_opener() opener.addheaders = [headers] install_opener(opener) urls = [&#123;\"name\": \"金属拉链\", \"url\": \"https://www.ykkfastening.com/cn/products/zipper/metal_zipper/?pno_941=\"&#125;, &#123;\"name\": \"尼龙拉链\", \"url\": \"https://www.ykkfastening.com/cn/products/zipper/coil_zipper/?pno_956=\"&#125;, &#123;\"name\": \"树脂拉链\", \"url\": \"https://www.ykkfastening.com/cn/products/zipper/vislon_zipper/?pno_957=\"&#125;] open_dict_url(urls)","categories":[{"name":"python","slug":"python","permalink":"https://wang-qp.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wang-qp.github.io/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"https://wang-qp.github.io/categories/python/"}]},{"title":"AC自动机","slug":"AC自动机","date":"2019-04-14T14:54:12.000Z","updated":"2020-06-04T00:57:09.293Z","comments":true,"path":"2019/04/14/AC自动机/","link":"","permalink":"https://wang-qp.github.io/2019/04/14/AC自动机/","excerpt":"","text":"##AC自动机 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const int N=1e6+9;int n;char ch[N];struct AC_automaton&#123; int ch[N][27],cnt[N],fail[N],pool; int ed[N],q[N],l,r; inline void insert(char *s,int id) &#123; int len=strlen(s+1),now=0; for(int i=1;i&lt;=len;i++) &#123; if(!ch[now][s[i]-'a']) ch[now][s[i]-'a']=++pool; now=ch[now][s[i]-'a']; cnt[now]++; &#125; ed[id]=now; &#125; inline void calc() &#123; fail[0]=0; q[r=1]=l=0; while(l&lt;r) &#123; int u=q[++l]; for(int i=0;i&lt;26;i++) if(ch[u][i]) &#123; q[++r]=ch[u][i]; fail[ch[u][i]]= u==0?0:ch[fail[u]][i]; &#125; else ch[u][i]= u==0?0:ch[fail[u]][i]; &#125; for(int i=r;i&gt;=1;i--) cnt[fail[q[i]]]+=cnt[q[i]]; for(int i=1;i&lt;=n;i++) printf(\"%d\\n\",cnt[ed[i]]); &#125;&#125;koishi;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf(\"%s\",ch+1); koishi.insert(ch,i); &#125; koishi.calc(); return 0;&#125; 参考","categories":[{"name":"算法","slug":"算法","permalink":"https://wang-qp.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wang-qp.github.io/tags/算法/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://wang-qp.github.io/categories/算法/"}]},{"title":"python数据分析","slug":"python","date":"2019-03-16T13:52:53.000Z","updated":"2020-06-04T00:57:09.307Z","comments":true,"path":"2019/03/16/python/","link":"","permalink":"https://wang-qp.github.io/2019/03/16/python/","excerpt":"","text":"《利用Python进行数据分析·第2版》Python利用sphinx构建个人博客使用Pelican和Github Pages搭建个人博客详细教程慕课网就业前端后端DjangoScrapy。。。","categories":[{"name":"python","slug":"python","permalink":"https://wang-qp.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wang-qp.github.io/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"https://wang-qp.github.io/categories/python/"}]},{"title":"k-means图像分割","slug":"k-means图像分割","date":"2019-03-14T11:34:37.000Z","updated":"2020-06-04T00:57:09.306Z","comments":true,"path":"2019/03/14/k-means图像分割/","link":"","permalink":"https://wang-qp.github.io/2019/03/14/k-means图像分割/","excerpt":"","text":"实现原理：将图片的每个像素点进行K-means聚类，然后生成新的图片。 参考资料：PIL库基础、数字图像处理、视觉机器学习 代码如下：123456789101112131415161718192021222324import numpy as npimport PIL.Image as imagefrom sklearn.cluster import KMeansdef load_data(file_path): f = open(file_path,'rb') #二进制打开 data = [] img = image.open(f) #以列表形式返回图片像素值 m,n = img.size #活的图片大小 for i in range(m): for j in range(n): #将每个像素点RGB颜色处理到0-1范围内并存放data x,y,z = img.getpixel((i,j)) data.append([x/256.0,y/256.0,z/256.0]) f.close() return np.mat(data),m,n #以矩阵型式返回data，图片大小img_data,row,col = load_data('img.jpg')label = KMeans(n_clusters=2).fit_predict(img_data) #聚类中心的个数为3label = label.reshape([row,col]) #聚类获得每个像素所属的类别pic_new = image.new(\"L\",(row,col)) #创建一张新的灰度图保存聚类后的结果for i in range(row): #根据所属类别向图片中添加灰度值 for j in range(col): pic_new.putpixel((i,j),int(256/(label[i][j]+1)))pic_new.save('new_img.jpg') sublime 虚拟环境","categories":[{"name":"python","slug":"python","permalink":"https://wang-qp.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wang-qp.github.io/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"https://wang-qp.github.io/categories/python/"}]},{"title":"python图片爬取","slug":"python图片爬取","date":"2019-03-10T15:06:11.000Z","updated":"2020-06-04T00:57:09.308Z","comments":true,"path":"2019/03/10/python图片爬取/","link":"","permalink":"https://wang-qp.github.io/2019/03/10/python图片爬取/","excerpt":"","text":"主要功能：爬取京东商城手机销售页面的手机图片，将其下载到本地文件夹。 代码如下：12345678910111213141516171819202122import urllib.requestimport redef f(url,page): http = urllib.request.urlopen(url).read() #打开传入的页面 http = str(http) #将网页内容转换为str类型 obj = '&lt;img width=\"220\" height=\"220\" data-img=\"1\" src=\"//(.*?\\.jpg)\"&gt;' #正则表示图片所存的网址 #img = re.compile(obj).findall(http) img = re.findall(obj,http) #将http中符合正则表示的保存在img列表，上行有同样效果 index = 1 for i in img: s = 'http://' + index #将图片网址加上(http://)前缀使其可以访问 try: urllib.request.urlretrieve(s,\"./img/pic\"+str(page)+str(index)+\".jpg\") #(urlretrieve)可以将s下载到对应的目录 except urllib.request.URLError as e: pass else: index += 1for i in range(1,80): url = 'https://list.jd.com/list.html?cat=9987,653,655&amp;page=' + str(i) #前为京东手机选购的网址，page 为该网页的所在的页数 f(url,i)","categories":[{"name":"python","slug":"python","permalink":"https://wang-qp.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wang-qp.github.io/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"https://wang-qp.github.io/categories/python/"}]}]}